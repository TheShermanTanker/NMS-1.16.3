/*      */ package net.minecraft.server.v1_16_R2;
/*      */ import com.destroystokyo.paper.event.entity.EntityKnockbackByEntityEvent;
/*      */ import com.destroystokyo.paper.event.player.PlayerArmorChangeEvent;
/*      */ import com.google.common.base.Function;
/*      */ import com.google.common.collect.ImmutableList;
/*      */ import com.google.common.collect.Lists;
/*      */ import com.google.common.collect.Maps;
/*      */ import com.mojang.datafixers.util.Pair;
/*      */ import com.mojang.serialization.DataResult;
/*      */ import com.mojang.serialization.Dynamic;
/*      */ import com.tuinity.tuinity.util.CachedLists;
/*      */ import java.util.ArrayList;
/*      */ import java.util.Collection;
/*      */ import java.util.ConcurrentModificationException;
/*      */ import java.util.Iterator;
/*      */ import java.util.List;
/*      */ import java.util.Map;
/*      */ import java.util.Objects;
/*      */ import java.util.Optional;
/*      */ import java.util.Random;
/*      */ import java.util.UUID;
/*      */ import java.util.function.Predicate;
/*      */ import javax.annotation.Nullable;
/*      */ import org.apache.logging.log4j.Logger;
/*      */ import org.bukkit.Location;
/*      */ import org.bukkit.World;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.attribute.CraftAttributeMap;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.entity.CraftLivingEntity;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.entity.CraftPlayer;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.event.CraftEventFactory;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.inventory.CraftItemStack;
/*      */ import org.bukkit.entity.Entity;
/*      */ import org.bukkit.entity.ExperienceOrb;
/*      */ import org.bukkit.entity.LivingEntity;
/*      */ import org.bukkit.entity.Player;
/*      */ import org.bukkit.event.Event;
/*      */ import org.bukkit.event.entity.ArrowBodyCountChangeEvent;
/*      */ import org.bukkit.event.entity.EntityDamageEvent;
/*      */ import org.bukkit.event.entity.EntityDeathEvent;
/*      */ import org.bukkit.event.entity.EntityPotionEffectEvent;
/*      */ import org.bukkit.event.entity.EntityRegainHealthEvent;
/*      */ import org.bukkit.event.entity.EntityResurrectEvent;
/*      */ import org.bukkit.event.entity.EntityTeleportEvent;
/*      */ import org.bukkit.event.player.PlayerItemConsumeEvent;
/*      */ import org.bukkit.inventory.ItemStack;
/*      */ import org.bukkit.util.Vector;
/*      */ import org.spigotmc.AsyncCatcher;
/*      */ 
/*      */ public abstract class EntityLiving extends Entity {
/*   50 */   private static final UUID b = UUID.fromString("662A6B8D-DA3E-4C1C-8813-96EA6097278D");
/*   51 */   private static final UUID c = UUID.fromString("87f46a96-686f-4796-b035-22e16ee9e038");
/*   52 */   private static final AttributeModifier d = new AttributeModifier(b, "Sprinting speed boost", 0.30000001192092896D, AttributeModifier.Operation.MULTIPLY_TOTAL);
/*   53 */   protected static final DataWatcherObject<Byte> ag = DataWatcher.a((Class)EntityLiving.class, DataWatcherRegistry.a);
/*   54 */   public static final DataWatcherObject<Float> HEALTH = DataWatcher.a((Class)EntityLiving.class, DataWatcherRegistry.c);
/*   55 */   private static final DataWatcherObject<Integer> f = DataWatcher.a((Class)EntityLiving.class, DataWatcherRegistry.b);
/*   56 */   private static final DataWatcherObject<Boolean> g = DataWatcher.a((Class)EntityLiving.class, DataWatcherRegistry.i);
/*   57 */   public static final DataWatcherObject<Integer> ARROWS_IN_BODY = DataWatcher.a((Class)EntityLiving.class, DataWatcherRegistry.b);
/*   58 */   private static final DataWatcherObject<Integer> bi = DataWatcher.a((Class)EntityLiving.class, DataWatcherRegistry.b);
/*   59 */   private static final DataWatcherObject<Optional<BlockPosition>> bj = DataWatcher.a((Class)EntityLiving.class, DataWatcherRegistry.m);
/*   60 */   protected static final EntitySize ah = EntitySize.c(0.2F, 0.2F);
/*      */   private final AttributeMapBase attributeMap;
/*   62 */   public CombatTracker combatTracker = new CombatTracker(this);
/*   63 */   public final Map<MobEffectList, MobEffect> effects = Maps.newHashMap(); private final NonNullList<ItemStack> bn; private final NonNullList<ItemStack> bo; public boolean ai; public EnumHand aj; public int ak; public int arrowCooldown; public int am; public int hurtTicks; public int hurtDuration; public float ap; public int deathTicks; public float ar; public float as; protected int at; public float au; public float av; public float aw; public int maxNoDamageTicks; public final float ay; public final float az; public float aA; public float aB; public float aC; public float aD; public float aE; @Nullable
/*      */   public EntityHuman killer; public int lastDamageByPlayerTime; protected boolean killed; protected int ticksFarFromPlayer; protected float aJ; protected float aK; protected float aL; protected float aM; protected float aN; protected int aO; public float lastDamage; public boolean jumping;
/*      */   public float aR;
/*      */   public float aS;
/*      */   public float aT;
/*      */   protected int aU;
/*      */   protected double aV;
/*      */   protected double aW;
/*      */   protected double aX;
/*      */   protected double aY;
/*      */   protected double aZ;
/*      */   protected double ba;
/*      */   protected int bb;
/*      */   public boolean updateEffects;
/*      */   @Nullable
/*      */   public EntityLiving lastDamager;
/*      */   public int hurtTimestamp;
/*      */   private EntityLiving bs;
/*      */   private int bt;
/*      */   private float bu;
/*      */   private int jumpTicks;
/*      */   private float bw;
/*      */   public ItemStack activeItem;
/*      */   protected int bd;
/*      */   protected int be;
/*      */   private BlockPosition bx;
/*      */   private Optional<BlockPosition> by;
/*      */   private DamageSource bz;
/*      */   private long bA;
/*      */   protected int bf;
/*      */   private float bB;
/*      */   private float bC;
/*      */   protected BehaviorController<?> bg;
/*      */   public int expToDrop;
/*      */   
/*      */   protected int getKillCount() {
/*   99 */     return this.aO;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   protected final int getEatTimeTicks()
/*      */   {
/*  123 */     return this.bd; } protected final void setEatTimeTicks(int value) { this.bd = value; }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  135 */   public int maxAirTicks = 300;
/*      */   boolean forceDrops;
/*  137 */   ArrayList<ItemStack> drops = new ArrayList<>();
/*      */   public final CraftAttributeMap craftAttributes;
/*      */   public boolean collides = true;
/*  140 */   public Set<UUID> collidableExemptions = new HashSet<>(); public boolean canPickUpLoot;
/*      */   public CraftLivingEntity getBukkitLivingEntity() {
/*  142 */     return (CraftLivingEntity)getBukkitEntity();
/*      */   }
/*      */   public boolean silentDeath = false; private boolean isTickingEffects; private List<ProcessableEffect> effectsToProcess; protected long eatStartTime; protected int totalEatTimeTicks; public int shieldBlockingDelay;
/*      */   
/*      */   public float getBukkitYaw() {
/*  147 */     return getHeadRotation();
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public void inactiveTick() {
/*  153 */     super.inactiveTick();
/*  154 */     this.ticksFarFromPlayer++;
/*      */   }
/*      */   
/*      */   protected EntityLiving(EntityTypes<? extends EntityLiving> entitytypes, World world)
/*      */   {
/*  159 */     super(entitytypes, world);
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/*  683 */     this.isTickingEffects = false;
/*  684 */     this.effectsToProcess = Lists.newArrayList();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 3608 */     this.shieldBlockingDelay = this.world.paperConfig.shieldBlockingDelay; this.bn = NonNullList.a(2, ItemStack.b); this.bo = NonNullList.a(4, ItemStack.b); this.maxNoDamageTicks = 20; this.aE = 0.02F; this.updateEffects = true; this.activeItem = ItemStack.b; this.by = Optional.empty(); this.attributeMap = new AttributeMapBase(AttributeDefaults.a(entitytypes)); this.craftAttributes = new CraftAttributeMap(this.attributeMap); this.datawatcher.set(HEALTH, Float.valueOf((float)getAttributeInstance(GenericAttributes.MAX_HEALTH).getValue())); this.i = true; this.az = (float)((Math.random() + 1.0D) * 0.009999999776482582D); ae(); this.ay = (float)Math.random() * 12398.0F; this.yaw = (float)(Math.random() * 6.2831854820251465D); this.aC = this.yaw; this.G = 0.6F; DynamicOpsNBT dynamicopsnbt = DynamicOpsNBT.a; this.bg = a(new Dynamic(dynamicopsnbt, dynamicopsnbt.createMap((Map)ImmutableMap.of(dynamicopsnbt.createString("memories"), dynamicopsnbt.emptyMap())))); } public BehaviorController<?> getBehaviorController() { return this.bg; } protected BehaviorController.b<?> cJ() { return BehaviorController.a((Collection<? extends MemoryModuleType<?>>)ImmutableList.of(), (Collection<? extends SensorType<? extends Sensor<?>>>)ImmutableList.of()); } protected BehaviorController<?> a(Dynamic<?> dynamic) { return cJ().a(dynamic); } public void killEntity() { damageEntity(DamageSource.OUT_OF_WORLD, Float.MAX_VALUE); } public boolean a(EntityTypes<?> entitytypes) { return true; } protected void initDatawatcher() { this.datawatcher.register(ag, Byte.valueOf((byte)0)); this.datawatcher.register(f, Integer.valueOf(0)); this.datawatcher.register(g, Boolean.valueOf(false)); this.datawatcher.register(ARROWS_IN_BODY, Integer.valueOf(0)); this.datawatcher.register(bi, Integer.valueOf(0)); this.datawatcher.register(HEALTH, Float.valueOf(1.0F)); this.datawatcher.register(bj, Optional.empty()); } public static AttributeProvider.Builder cK() { return AttributeProvider.a().a(GenericAttributes.MAX_HEALTH).a(GenericAttributes.KNOCKBACK_RESISTANCE).a(GenericAttributes.MOVEMENT_SPEED).a(GenericAttributes.ARMOR).a(GenericAttributes.ARMOR_TOUGHNESS); } protected void a(double d0, boolean flag, IBlockData iblockdata, BlockPosition blockposition) { if (!isInWater()) aK();  if (!this.world.isClientSide && flag && this.fallDistance > 0.0F) { cP(); cQ(); }  if (!this.world.isClientSide && this.fallDistance > 3.0F && flag) { float f = MathHelper.f(this.fallDistance - 3.0F); if (!iblockdata.isAir()) { double d1 = Math.min((0.2F + f / 15.0F), 2.5D); int i = (int)(150.0D * d1); if (this instanceof EntityPlayer) { ((WorldServer)this.world).sendParticles((EntityPlayer)this, new ParticleParamBlock(Particles.BLOCK, iblockdata), locX(), locY(), locZ(), i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, false); } else { ((WorldServer)this.world).a(new ParticleParamBlock(Particles.BLOCK, iblockdata), locX(), locY(), locZ(), i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D); }  }  }  super.a(d0, flag, iblockdata, blockposition); } public boolean canBreatheUnderwater() { return cL(); } public boolean cL() { return (getMonsterType() == EnumMonsterType.UNDEAD); } public void entityBaseTick() { this.ar = this.as; if (this.justCreated) getBedPosition().ifPresent(this::a);  if (cM()) cN();  super.entityBaseTick(); this.world.getMethodProfiler().enter("livingEntityBaseTick"); boolean flag = this instanceof EntityHuman; if (isAlive()) if (inBlock()) { damageEntity(DamageSource.STUCK, 1.0F); } else if (flag && !this.world.getWorldBorder().a(getBoundingBox())) { double d0 = this.world.getWorldBorder().a(this) + this.world.getWorldBorder().getDamageBuffer(); if (d0 < 0.0D) { double d1 = this.world.getWorldBorder().getDamageAmount(); if (d1 > 0.0D) damageEntity(DamageSource.STUCK, Math.max(1, MathHelper.floor(-d0 * d1)));  }  }   if (isFireProof() || this.world.isClientSide) extinguish();  boolean flag1 = (flag && ((EntityHuman)this).abilities.isInvulnerable); if (isAlive()) { if (a(TagsFluid.WATER) && !this.world.getType(new BlockPosition(locX(), getHeadY(), locZ())).a(Blocks.BUBBLE_COLUMN)) { if (!canBreatheUnderwater() && !MobEffectUtil.c(this) && !flag1) { setAirTicks(l(getAirTicks())); if (getAirTicks() == -20) { setAirTicks(0); Vec3D vec3d = getMot(); for (int i = 0; i < 8; i++) { double d2 = this.random.nextDouble() - this.random.nextDouble(); double d3 = this.random.nextDouble() - this.random.nextDouble(); double d4 = this.random.nextDouble() - this.random.nextDouble(); this.world.addParticle(Particles.BUBBLE, locX() + d2, locY() + d3, locZ() + d4, vec3d.x, vec3d.y, vec3d.z); }  damageEntity(DamageSource.DROWN, 2.0F); }  }  if (!this.world.isClientSide && isPassenger() && getVehicle() != null && !getVehicle().bs()) stopRiding();  } else if (getAirTicks() < bG()) { setAirTicks(m(getAirTicks())); }  if (!this.world.isClientSide) { BlockPosition blockposition = getChunkCoordinates(); if (!Objects.equal(this.bx, blockposition)) { this.bx = blockposition; c(blockposition); }  }  }  if (isAlive() && aF()) extinguish();  if (this.hurtTicks > 0) this.hurtTicks--;  if (this.noDamageTicks > 0 && !(this instanceof EntityPlayer)) this.noDamageTicks--;  if (dk()) cT();  if (this.lastDamageByPlayerTime > 0) { this.lastDamageByPlayerTime--; } else { this.killer = null; }  if (this.bs != null && !this.bs.isAlive()) this.bs = null;  if (this.lastDamager != null) if (!this.lastDamager.isAlive()) { setLastDamager((EntityLiving)null); } else if (this.ticksLived - this.hurtTimestamp > 100) { setLastDamager((EntityLiving)null); }   tickPotionEffects(); this.aM = this.aL; this.aB = this.aA; this.aD = this.aC; this.lastYaw = this.yaw; this.lastPitch = this.pitch; this.world.getMethodProfiler().exit(); } public boolean cM() { return (this.ticksLived % 5 == 0 && (getMot()).x != 0.0D && (getMot()).z != 0.0D && !isSpectator() && EnchantmentManager.j(this) && cO()); } protected void cN() { Vec3D vec3d = getMot(); this.world.addParticle(Particles.SOUL, locX() + (this.random.nextDouble() - 0.5D) * getWidth(), locY() + 0.1D, locZ() + (this.random.nextDouble() - 0.5D) * getWidth(), vec3d.x * -0.2D, 0.1D, vec3d.z * -0.2D); float f = (this.random.nextFloat() * 0.4F + this.random.nextFloat() > 0.9F) ? 0.6F : 0.0F; playSound(SoundEffects.PARTICLE_SOUL_ESCAPE, f, 0.6F + this.random.nextFloat() * 0.4F); } protected boolean cO() { return this.world.getType(ar()).a(TagsBlock.SOUL_SPEED_BLOCKS); } protected float getBlockSpeedFactor() { return (cO() && EnchantmentManager.a(Enchantments.SOUL_SPEED, this) > 0) ? 1.0F : super.getBlockSpeedFactor(); } protected boolean b(IBlockData iblockdata) { return (!iblockdata.isAir() || isGliding()); } protected void cP() { AttributeModifiable attributemodifiable = getAttributeInstance(GenericAttributes.MOVEMENT_SPEED); if (attributemodifiable != null && attributemodifiable.a(c) != null) attributemodifiable.b(c);  } protected void cQ() { if (!aM().isAir()) { int i = EnchantmentManager.a(Enchantments.SOUL_SPEED, this); if (i > 0 && cO()) { AttributeModifiable attributemodifiable = getAttributeInstance(GenericAttributes.MOVEMENT_SPEED); if (attributemodifiable == null) return;  attributemodifiable.b(new AttributeModifier(c, "Soul speed boost", (0.03F * (1.0F + i * 0.35F)), AttributeModifier.Operation.ADDITION)); if (getRandom().nextFloat() < 0.04F) { ItemStack itemstack = getEquipment(EnumItemSlot.FEET); itemstack.damage(1, this, entityliving -> entityliving.broadcastItemBreak(EnumItemSlot.FEET)); }  }  }  } protected void c(BlockPosition blockposition) { int i = EnchantmentManager.a(Enchantments.FROST_WALKER, this); if (i > 0) EnchantmentFrostWalker.a(this, this.world, blockposition, i);  if (b(aM())) cP();  cQ(); } public boolean isBaby() { return false; } public float cR() { return isBaby() ? 0.5F : 1.0F; } protected boolean cS() { return true; } public boolean bs() { return false; } protected void cT() { this.deathTicks++; if (this.deathTicks >= 20 && !this.dead) { die(); for (int i = 0; i < 20; i++) { double d0 = this.random.nextGaussian() * 0.02D; double d1 = this.random.nextGaussian() * 0.02D; double d2 = this.random.nextGaussian() * 0.02D; this.world.addParticle(Particles.POOF, d(1.0D), cE(), g(1.0D), d0, d1, d2); }  }  } protected boolean isDropExperience() { return !isBaby(); } protected boolean cV() { return !isBaby(); } protected int l(int i) { int j = EnchantmentManager.getOxygenEnchantmentLevel(this); return (j > 0 && this.random.nextInt(j + 1) > 0) ? i : (i - 1); } protected int m(int i) { return Math.min(i + 4, bG()); } protected int getExpValue(EntityHuman entityhuman) { return 0; } protected boolean alwaysGivesExp() { return false; } public Random getRandom() { return this.random; } @Nullable public EntityLiving getLastDamager() { return this.lastDamager; } public int cZ() { return this.hurtTimestamp; } public void e(@Nullable EntityHuman entityhuman) { this.killer = entityhuman; this.lastDamageByPlayerTime = this.ticksLived; } public void setLastDamager(@Nullable EntityLiving entityliving) { this.lastDamager = entityliving; this.hurtTimestamp = this.ticksLived; } @Nullable public EntityLiving da() { return this.bs; } public int db() { return this.bt; } public void z(Entity entity) { if (entity instanceof EntityLiving) { this.bs = (EntityLiving)entity; } else { this.bs = null; }  this.bt = this.ticksLived; } public int dc() { return this.ticksFarFromPlayer; } public void n(int i) { this.ticksFarFromPlayer = i; } protected void b(ItemStack itemstack) { if (!itemstack.isEmpty()) { SoundEffect soundeffect = SoundEffects.ITEM_ARMOR_EQUIP_GENERIC; Item item = itemstack.getItem(); if (item instanceof ItemArmor) { soundeffect = ((ItemArmor)item).ab_().b(); } else if (item == Items.ELYTRA) { soundeffect = SoundEffects.ITEM_ARMOR_EQUIP_ELYTRA; }  playSound(soundeffect, 1.0F, 1.0F); }  } public void saveData(NBTTagCompound nbttagcompound) { nbttagcompound.setFloat("Health", getHealth()); nbttagcompound.setShort("HurtTime", (short)this.hurtTicks); nbttagcompound.setInt("HurtByTimestamp", this.hurtTimestamp); nbttagcompound.setShort("DeathTime", (short)this.deathTicks); nbttagcompound.setFloat("AbsorptionAmount", getAbsorptionHearts()); nbttagcompound.set("Attributes", getAttributeMap().c()); if (!this.effects.isEmpty()) { NBTTagList nbttaglist = new NBTTagList(); Iterator<MobEffect> iterator = this.effects.values().iterator(); while (iterator.hasNext()) { MobEffect mobeffect = iterator.next(); nbttaglist.add(mobeffect.a(new NBTTagCompound())); }  nbttagcompound.set("ActiveEffects", nbttaglist); }  nbttagcompound.setBoolean("FallFlying", isGliding()); getBedPosition().ifPresent(blockposition -> { nbttagcompound.setInt("SleepingX", blockposition.getX()); nbttagcompound.setInt("SleepingY", blockposition.getY()); nbttagcompound.setInt("SleepingZ", blockposition.getZ()); }); DataResult<NBTBase> dataresult = this.bg.a(DynamicOpsNBT.a); Logger logger = LOGGER; logger.getClass(); Objects.requireNonNull(logger); dataresult.resultOrPartial(logger::error).ifPresent(nbtbase -> nbttagcompound.set("Brain", nbtbase)); } public void loadData(NBTTagCompound nbttagcompound) { float absorptionAmount = nbttagcompound.getFloat("AbsorptionAmount"); if (Float.isNaN(absorptionAmount)) absorptionAmount = 0.0F;  setAbsorptionHearts(absorptionAmount); if (nbttagcompound.hasKeyOfType("Attributes", 9) && this.world != null && !this.world.isClientSide) getAttributeMap().a(nbttagcompound.getList("Attributes", 10));  if (nbttagcompound.hasKeyOfType("ActiveEffects", 9)) { NBTTagList nbttaglist = nbttagcompound.getList("ActiveEffects", 10); for (int i = 0; i < nbttaglist.size(); i++) { NBTTagCompound nbttagcompound1 = nbttaglist.getCompound(i); MobEffect mobeffect = MobEffect.b(nbttagcompound1); if (mobeffect != null) this.effects.put(mobeffect.getMobEffect(), mobeffect);  }  }  if (nbttagcompound.hasKey("Bukkit.MaxHealth")) { NBTBase nbtbase = nbttagcompound.get("Bukkit.MaxHealth"); if (nbtbase.getTypeId() == 5) { getAttributeInstance(GenericAttributes.MAX_HEALTH).setValue(((NBTTagFloat)nbtbase).asDouble()); } else if (nbtbase.getTypeId() == 3) { getAttributeInstance(GenericAttributes.MAX_HEALTH).setValue(((NBTTagInt)nbtbase).asDouble()); }  }  if (nbttagcompound.hasKeyOfType("Health", 99)) setHealth(nbttagcompound.getFloat("Health"));  this.hurtTicks = nbttagcompound.getShort("HurtTime"); this.deathTicks = nbttagcompound.getShort("DeathTime"); this.hurtTimestamp = nbttagcompound.getInt("HurtByTimestamp"); if (nbttagcompound.hasKeyOfType("Team", 8)) { String s = nbttagcompound.getString("Team"); ScoreboardTeam scoreboardteam = this.world.getScoreboard().getTeam(s); if (!this.world.paperConfig.nonPlayerEntitiesOnScoreboards && !(this instanceof EntityHuman)) scoreboardteam = null;  boolean flag = (scoreboardteam != null && this.world.getScoreboard().addPlayerToTeam(getUniqueIDString(), scoreboardteam)); if (!flag) LOGGER.warn("Unable to add mob to team \"{}\" (that team probably doesn't exist)", s);  }  if (nbttagcompound.getBoolean("FallFlying")) setFlag(7, true);  if (nbttagcompound.hasKeyOfType("SleepingX", 99) && nbttagcompound.hasKeyOfType("SleepingY", 99) && nbttagcompound.hasKeyOfType("SleepingZ", 99)) { BlockPosition blockposition = new BlockPosition(nbttagcompound.getInt("SleepingX"), nbttagcompound.getInt("SleepingY"), nbttagcompound.getInt("SleepingZ")); e(blockposition); this.datawatcher.set(POSE, EntityPose.SLEEPING); if (!this.justCreated) a(blockposition);  }  if (nbttagcompound.hasKeyOfType("Brain", 10)) this.bg = a(new Dynamic(DynamicOpsNBT.a, nbttagcompound.get("Brain")));  } private static class ProcessableEffect {
/*      */     private MobEffectList type; private MobEffect effect; private final EntityPotionEffectEvent.Cause cause; private ProcessableEffect(MobEffect effect, EntityPotionEffectEvent.Cause cause) { this.effect = effect; this.cause = cause; } private ProcessableEffect(MobEffectList type, EntityPotionEffectEvent.Cause cause) { this.type = type; this.cause = cause; } } protected void tickPotionEffects() { Iterator<MobEffectList> iterator = this.effects.keySet().iterator(); this.isTickingEffects = true; try { while (iterator.hasNext()) { MobEffectList mobeffectlist = iterator.next(); MobEffect mobeffect = this.effects.get(mobeffectlist); if (!mobeffect.tick(this, () -> a(mobeffect, true))) { if (!this.world.isClientSide) { EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, mobeffect, null, EntityPotionEffectEvent.Cause.EXPIRATION); if (event.isCancelled()) continue;  iterator.remove(); b(mobeffect); }  continue; }  if (mobeffect.getDuration() % 600 == 0) a(mobeffect, false);  }  } catch (ConcurrentModificationException concurrentModificationException) {} this.isTickingEffects = false; for (ProcessableEffect e : this.effectsToProcess) { if (e.effect != null) { addEffect(e.effect, e.cause); continue; }  removeEffect(e.type, e.cause); }  this.effectsToProcess.clear(); if (this.updateEffects) { if (!this.world.isClientSide) C();  this.updateEffects = false; }  int i = ((Integer)this.datawatcher.<Integer>get(f)).intValue(); boolean flag = ((Boolean)this.datawatcher.<Boolean>get(g)).booleanValue(); if (i > 0) { boolean flag1; int j; if (isInvisible()) { flag1 = (this.random.nextInt(15) == 0); } else { flag1 = this.random.nextBoolean(); }  if (flag) j = flag1 & ((this.random.nextInt(5) == 0) ? 1 : 0);  if (j != 0 && i > 0) { double d0 = (i >> 16 & 0xFF) / 255.0D; double d1 = (i >> 8 & 0xFF) / 255.0D; double d2 = (i >> 0 & 0xFF) / 255.0D; this.world.addParticle(flag ? Particles.AMBIENT_ENTITY_EFFECT : Particles.ENTITY_EFFECT, d(0.5D), cE(), g(0.5D), d0, d1, d2); }  }  } protected void C() { if (this.effects.isEmpty()) { de(); setInvisible(false); } else { Collection<MobEffect> collection = this.effects.values(); this.datawatcher.set(g, Boolean.valueOf(c(collection))); this.datawatcher.set(f, Integer.valueOf(PotionUtil.a(collection))); setInvisible(hasEffect(MobEffects.INVISIBILITY)); }  } public double A(@Nullable Entity entity) { double d0 = 1.0D; if (bw()) d0 *= 0.8D;  if (isInvisible()) { float f = dE(); if (f < 0.1F) f = 0.1F;  d0 *= 0.7D * f; }  if (entity != null) { ItemStack itemstack = getEquipment(EnumItemSlot.HEAD); Item item = itemstack.getItem(); EntityTypes<?> entitytypes = entity.getEntityType(); if ((entitytypes == EntityTypes.SKELETON && item == Items.SKELETON_SKULL) || (entitytypes == EntityTypes.ZOMBIE && item == Items.ZOMBIE_HEAD) || (entitytypes == EntityTypes.CREEPER && item == Items.CREEPER_HEAD)) d0 *= 0.5D;  }  return d0; } public boolean c(EntityLiving entityliving) { return true; } public boolean a(EntityLiving entityliving, PathfinderTargetCondition pathfindertargetcondition) { return pathfindertargetcondition.a(this, entityliving); } public static boolean c(Collection<MobEffect> collection) { MobEffect mobeffect; Iterator<MobEffect> iterator = collection.iterator(); do { if (!iterator.hasNext()) return true;  mobeffect = iterator.next(); } while (mobeffect.isAmbient()); return false; } protected void de() { this.datawatcher.set(g, Boolean.valueOf(false)); this.datawatcher.set(f, Integer.valueOf(0)); } public boolean removeAllEffects() { return removeAllEffects(EntityPotionEffectEvent.Cause.UNKNOWN); } public boolean removeAllEffects(EntityPotionEffectEvent.Cause cause) { if (this.world.isClientSide) return false;  Iterator<MobEffect> iterator = this.effects.values().iterator(); boolean flag; for (flag = false; iterator.hasNext(); flag = true) { MobEffect effect = iterator.next(); EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, effect, null, cause, EntityPotionEffectEvent.Action.CLEARED); if (!event.isCancelled()) { b(effect); iterator.remove(); }  }  return flag; } public Collection<MobEffect> getEffects() { return this.effects.values(); } public Map<MobEffectList, MobEffect> dh() { return this.effects; } public boolean hasEffect(MobEffectList mobeffectlist) { return this.effects.containsKey(mobeffectlist); } @Nullable public MobEffect getEffect(MobEffectList mobeffectlist) { return this.effects.get(mobeffectlist); } public boolean addEffect(MobEffect mobeffect) { return addEffect(mobeffect, EntityPotionEffectEvent.Cause.UNKNOWN); } public boolean addEffect(MobEffect mobeffect, EntityPotionEffectEvent.Cause cause) { AsyncCatcher.catchOp("effect add"); if (this.isTickingEffects) { this.effectsToProcess.add(new ProcessableEffect(mobeffect, cause)); return true; }  if (!d(mobeffect)) return false;  MobEffect mobeffect1 = this.effects.get(mobeffect.getMobEffect()); boolean override = false; if (mobeffect1 != null) override = (new MobEffect(mobeffect1)).b(mobeffect);  EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, mobeffect1, mobeffect, cause, override); if (event.isCancelled()) return false;  if (mobeffect1 == null) { this.effects.put(mobeffect.getMobEffect(), mobeffect); a(mobeffect); return true; }  if (event.isOverride()) { mobeffect1.b(mobeffect); a(mobeffect1, true); return true; }  return false; } public boolean d(MobEffect mobeffect) { if (getMonsterType() == EnumMonsterType.UNDEAD) { MobEffectList mobeffectlist = mobeffect.getMobEffect(); if (mobeffectlist == MobEffects.REGENERATION || mobeffectlist == MobEffects.POISON) return false;  }  return true; } public boolean di() { return (getMonsterType() == EnumMonsterType.UNDEAD); } @Nullable public MobEffect c(@Nullable MobEffectList mobeffectlist) { return c(mobeffectlist, EntityPotionEffectEvent.Cause.UNKNOWN); } @Nullable public MobEffect c(@Nullable MobEffectList mobeffectlist, EntityPotionEffectEvent.Cause cause) { if (this.isTickingEffects) { this.effectsToProcess.add(new ProcessableEffect(mobeffectlist, cause)); return null; }  MobEffect effect = this.effects.get(mobeffectlist); if (effect == null) return null;  EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, effect, null, cause); if (event.isCancelled()) return null;  return this.effects.remove(mobeffectlist); } public boolean removeEffect(MobEffectList mobeffectlist) { return removeEffect(mobeffectlist, EntityPotionEffectEvent.Cause.UNKNOWN); } public boolean removeEffect(MobEffectList mobeffectlist, EntityPotionEffectEvent.Cause cause) { MobEffect mobeffect = c(mobeffectlist, cause); if (mobeffect != null) { b(mobeffect); return true; }  return false; } protected void a(MobEffect mobeffect) { this.updateEffects = true; if (!this.world.isClientSide) mobeffect.getMobEffect().b(this, getAttributeMap(), mobeffect.getAmplifier());  } protected void a(MobEffect mobeffect, boolean flag) { this.updateEffects = true; if (flag && !this.world.isClientSide) { MobEffectList mobeffectlist = mobeffect.getMobEffect(); mobeffectlist.a(this, getAttributeMap(), mobeffect.getAmplifier()); mobeffectlist.b(this, getAttributeMap(), mobeffect.getAmplifier()); }  } protected void b(MobEffect mobeffect) { this.updateEffects = true; if (!this.world.isClientSide) mobeffect.getMobEffect().a(this, getAttributeMap(), mobeffect.getAmplifier());  } public void heal(float f) { heal(f, EntityRegainHealthEvent.RegainReason.CUSTOM); } public void heal(float f, EntityRegainHealthEvent.RegainReason regainReason) { heal(f, regainReason, false); } public void heal(float f, EntityRegainHealthEvent.RegainReason regainReason, boolean isFastRegen) { float f1 = getHealth(); if (f1 > 0.0F) { EntityRegainHealthEvent event = new EntityRegainHealthEvent((Entity)getBukkitEntity(), f, regainReason, isFastRegen); if (this.valid) this.world.getServer().getPluginManager().callEvent((Event)event);  if (!event.isCancelled()) setHealth((float)(getHealth() + event.getAmount()));  }  } public float getHealth() { if (this instanceof EntityPlayer) return (float)((EntityPlayer)this).getBukkitEntity().getHealth();  return ((Float)this.datawatcher.<Float>get(HEALTH)).floatValue(); } public void setHealth(float f) { if (Float.isNaN(f)) { f = getMaxHealth(); if (this.valid) System.err.println("[NAN-HEALTH] " + getName() + " had NaN health set");  }  if (this instanceof EntityPlayer) { CraftPlayer player = ((EntityPlayer)this).getBukkitEntity(); if (f < 0.0F) { player.setRealHealth(0.0D); } else if (f > player.getMaxHealth()) { player.setRealHealth(player.getMaxHealth()); } else { player.setRealHealth(f); }  player.updateScaledHealth(false); return; }  this.datawatcher.set(HEALTH, Float.valueOf(MathHelper.a(f, 0.0F, getMaxHealth()))); } public boolean dk() { return (getHealth() <= 0.0F); } public boolean damageEntity(DamageSource damagesource, float f) { if (isInvulnerable(damagesource)) return false;  if (this.world.isClientSide) return false;  if (this.dead || this.killed || getHealth() <= 0.0F) return false;  if (damagesource.isFire() && hasEffect(MobEffects.FIRE_RESISTANCE)) return false;  if (isSleeping() && !this.world.isClientSide) entityWakeup();  this.ticksFarFromPlayer = 0; float f1 = f; boolean flag = (f > 0.0F && applyBlockingModifier(damagesource)); float f2 = 0.0F; this.av = 1.5F; boolean flag1 = true; if (this.noDamageTicks > 10.0F) { if (f <= this.lastDamage) { this.forceExplosionKnockback = true; return false; }  if (!damageEntity0(damagesource, f - this.lastDamage)) return false;  this.lastDamage = f; flag1 = false; } else { if (!damageEntity0(damagesource, f)) return false;  this.lastDamage = f; this.noDamageTicks = 20; this.hurtDuration = 10; this.hurtTicks = this.hurtDuration; }  if (this instanceof EntityAnimal) { ((EntityAnimal)this).resetLove(); if (this instanceof EntityTameableAnimal) ((EntityTameableAnimal)this).setWillSit(false);  }  this.ap = 0.0F; Entity entity1 = damagesource.getEntity(); if (entity1 != null) { if (entity1 instanceof EntityLiving) setLastDamager((EntityLiving)entity1);  if (entity1 instanceof EntityHuman) { this.lastDamageByPlayerTime = 100; this.killer = (EntityHuman)entity1; } else if (entity1 instanceof EntityWolf) { EntityWolf entitywolf = (EntityWolf)entity1; if (entitywolf.isTamed()) { this.lastDamageByPlayerTime = 100; EntityLiving entityliving = entitywolf.getOwner(); if (entityliving != null && entityliving.getEntityType() == EntityTypes.PLAYER) { this.killer = (EntityHuman)entityliving; } else { this.killer = null; }  }  }  }  boolean knockbackCancelled = (this.world.paperConfig.disableExplosionKnockback && damagesource.isExplosion() && this instanceof EntityHuman); if (flag1) { if (flag) { this.world.broadcastEntityEffect(this, (byte)29); } else if (damagesource instanceof EntityDamageSource && ((EntityDamageSource)damagesource).y()) { this.world.broadcastEntityEffect(this, (byte)33); } else { byte b0; if (damagesource == DamageSource.DROWN) { b0 = 36; } else if (damagesource.isFire()) { b0 = 37; } else if (damagesource == DamageSource.SWEET_BERRY_BUSH) { b0 = 44; } else { b0 = 2; }  if (!knockbackCancelled) this.world.broadcastEntityEffect(this, b0);  }  if (damagesource != DamageSource.DROWN && (!flag || f > 0.0F)) velocityChanged();  if (entity1 != null) { double d0 = entity1.locX() - locX(); double d1; for (d1 = entity1.locZ() - locZ(); d0 * d0 + d1 * d1 < 1.0E-4D; d1 = (Math.random() - Math.random()) * 0.01D) d0 = (Math.random() - Math.random()) * 0.01D;  this.ap = (float)(MathHelper.d(d1, d0) * 57.2957763671875D - this.yaw); doKnockback(0.4F, d0, d1, entity1); } else { this.ap = ((int)(Math.random() * 2.0D) * 180); }  }  if (knockbackCancelled) this.world.broadcastEntityEffect(this, (byte)2);  if (dk()) { if (!f(damagesource)) { this.silentDeath = !flag1; die(damagesource); this.silentDeath = false; }  } else if (flag1) { c(damagesource); }  boolean flag2 = (!flag || f > 0.0F); if (flag2) { this.bz = damagesource; this.bA = this.world.getTime(); }  if (this instanceof EntityPlayer) { CriterionTriggers.h.a((EntityPlayer)this, damagesource, f1, f, flag); if (f2 > 0.0F && f2 < 3.4028235E37F) ((EntityPlayer)this).a(StatisticList.DAMAGE_BLOCKED_BY_SHIELD, Math.round(f2 * 10.0F));  }  if (entity1 instanceof EntityPlayer) CriterionTriggers.g.a((EntityPlayer)entity1, this, damagesource, f1, f, flag);  return flag2; } protected void shieldBlock(EntityLiving entityliving) { entityliving.e(this); } protected void e(EntityLiving entityliving) { entityliving.doKnockback(0.5F, entityliving.locX() - locX(), entityliving.locZ() - locZ(), this); } private boolean f(DamageSource damagesource) { if (damagesource.ignoresInvulnerability()) return false;  ItemStack itemstack = null; EnumHand[] aenumhand = EnumHand.values(); int i = aenumhand.length; ItemStack itemstack1 = ItemStack.b; for (int j = 0; j < i; j++) { EnumHand enumhand = aenumhand[j]; itemstack1 = b(enumhand); if (itemstack1.getItem() == Items.TOTEM_OF_UNDYING) { itemstack = itemstack1.cloneItemStack(); break; }  }  EntityResurrectEvent event = new EntityResurrectEvent((LivingEntity)getBukkitEntity()); event.setCancelled((itemstack == null)); this.world.getServer().getPluginManager().callEvent((Event)event); if (!event.isCancelled()) { if (!itemstack1.isEmpty()) itemstack1.subtract(1);  if (itemstack != null && this instanceof EntityPlayer) { EntityPlayer entityplayer = (EntityPlayer)this; entityplayer.b(StatisticList.ITEM_USED.b(Items.TOTEM_OF_UNDYING)); CriterionTriggers.B.a(entityplayer, itemstack); }  setHealth(1.0F); removeAllEffects(EntityPotionEffectEvent.Cause.TOTEM); addEffect(new MobEffect(MobEffects.REGENERATION, 900, 1), EntityPotionEffectEvent.Cause.TOTEM); addEffect(new MobEffect(MobEffects.ABSORBTION, 100, 1), EntityPotionEffectEvent.Cause.TOTEM); addEffect(new MobEffect(MobEffects.FIRE_RESISTANCE, 800, 0), EntityPotionEffectEvent.Cause.TOTEM); this.world.broadcastEntityEffect(this, (byte)35); }  return !event.isCancelled(); } @Nullable public DamageSource dl() { if (this.world.getTime() - this.bA > 40L) this.bz = null;  return this.bz; } protected void c(DamageSource damagesource) { SoundEffect soundeffect = getSoundHurt(damagesource); if (soundeffect != null) playSound(soundeffect, getSoundVolume(), dG());  } private boolean applyBlockingModifier(DamageSource damagesource) { Entity entity = damagesource.j(); boolean flag = false; if (entity instanceof EntityArrow) { EntityArrow entityarrow = (EntityArrow)entity; if (entityarrow.getPierceLevel() > 0) flag = true;  }  if (!damagesource.ignoresArmor() && isBlocking() && !flag) { Vec3D vec3d = damagesource.w(); if (vec3d != null) { Vec3D vec3d1 = f(1.0F); Vec3D vec3d2 = vec3d.a(getPositionVector()).d(); vec3d2 = new Vec3D(vec3d2.x, 0.0D, vec3d2.z); if (vec3d2.b(vec3d1) < 0.0D) return true;  }  }  return false; } public void die(DamageSource damagesource) { if (!this.dead && !this.killed) { Entity entity = damagesource.getEntity(); EntityLiving entityliving = getKillingEntity(); this.killed = true; if (this.world instanceof WorldServer) { if (entity != null); EntityDeathEvent deathEvent = d(damagesource); if (deathEvent == null || !deathEvent.isCancelled()) { if (getKillCount() >= 0 && entityliving != null) entityliving.runKillTrigger(this, getKillCount(), damagesource);  if (isSleeping()) entityWakeup();  getCombatTracker().reset(); if (entity != null) entity.onKill((WorldServer)this.world, this);  } else { this.killed = false; setHealth((float)deathEvent.getReviveHealth()); }  f(entityliving); }  if (this.killed) { this.world.broadcastEntityEffect(this, (byte)3); setPose(EntityPose.DYING); }  }  } protected void f(@Nullable EntityLiving entityliving) { if (!this.world.isClientSide) { boolean flag = false; if (this.killed && entityliving instanceof EntityWither) { if (this.world.getGameRules().getBoolean(GameRules.MOB_GRIEFING)) { BlockPosition blockposition = getChunkCoordinates(); IBlockData iblockdata = Blocks.WITHER_ROSE.getBlockData(); if (this.world.getType(blockposition).isAir() && iblockdata.canPlace(this.world, blockposition)) { this.world.setTypeAndData(blockposition, iblockdata, 3); flag = true; }  }  if (!flag) { EntityItem entityitem = new EntityItem(this.world, locX(), locY(), locZ(), new ItemStack(Items.bt)); this.world.addEntity(entityitem); }  }  }  } protected EntityDeathEvent processDeath(DamageSource damagesource) { return d(damagesource); } protected EntityDeathEvent d(DamageSource damagesource) { int i; Entity entity = damagesource.getEntity(); if (entity instanceof EntityHuman) { i = EnchantmentManager.g((EntityLiving)entity); } else { i = 0; }  boolean flag = (this.lastDamageByPlayerTime > 0); dropInventory(); if (cV() && this.world.getGameRules().getBoolean(GameRules.DO_MOB_LOOT)) { a(damagesource, flag); dropDeathLoot(damagesource, i, flag); }  EntityDeathEvent deathEvent = CraftEventFactory.callEntityDeathEvent(this, this.drops); postDeathDropItems(deathEvent); this.drops = new ArrayList<>(); dropExperience(); return deathEvent; } protected void dropInventory() {} protected void postDeathDropItems(EntityDeathEvent event) {} public int getExpReward() { if (!this.world.isClientSide && (alwaysGivesExp() || (this.lastDamageByPlayerTime > 0 && isDropExperience() && this.world.getGameRules().getBoolean(GameRules.DO_MOB_LOOT)))) { int i = getExpValue(this.killer); return i; }  return 0; } protected void dropExperience() { int i = this.expToDrop; while (i > 0) { int j = EntityExperienceOrb.getOrbValue(i); i -= j; EntityLiving attacker = (this.killer != null) ? this.killer : this.lastDamager; this.world.addEntity(new EntityExperienceOrb(this.world, locX(), locY(), locZ(), j, (this instanceof EntityPlayer) ? ExperienceOrb.SpawnReason.PLAYER_DEATH : ExperienceOrb.SpawnReason.ENTITY_DEATH, attacker, this)); }  this.expToDrop = 0; } protected void dropDeathLoot(DamageSource damagesource, int i, boolean flag) {} public MinecraftKey do_() { return getEntityType().i(); } protected void a(DamageSource damagesource, boolean flag) { MinecraftKey minecraftkey = do_(); LootTable loottable = this.world.getMinecraftServer().getLootTableRegistry().getLootTable(minecraftkey); LootTableInfo.Builder loottableinfo_builder = a(flag, damagesource); loottable.populateLoot(loottableinfo_builder.build(LootContextParameterSets.ENTITY), this::a); } protected LootTableInfo.Builder a(boolean flag, DamageSource damagesource) { LootTableInfo.Builder loottableinfo_builder = (new LootTableInfo.Builder((WorldServer)this.world)).a(this.random).<Entity>set(LootContextParameters.THIS_ENTITY, this).<Vec3D>set(LootContextParameters.ORIGIN, getPositionVector()).<DamageSource>set(LootContextParameters.DAMAGE_SOURCE, damagesource).<Entity>setOptional(LootContextParameters.KILLER_ENTITY, damagesource.getEntity()).setOptional(LootContextParameters.DIRECT_KILLER_ENTITY, damagesource.j()); if (flag && this.killer != null) loottableinfo_builder = loottableinfo_builder.<EntityHuman>set(LootContextParameters.LAST_DAMAGE_PLAYER, this.killer).a(this.killer.eT());  return loottableinfo_builder; } public void a(float f, double d0, double d1) { doKnockback(f, d0, d1, (Entity)null); } public void doKnockback(float f, double d0, double d1, Entity knockingBackEntity) { f = (float)(f * (1.0D - b(GenericAttributes.KNOCKBACK_RESISTANCE))); if (f > 0.0F) { this.impulse = true; Vec3D vec3d = getMot(); Vec3D vec3d1 = (new Vec3D(d0, 0.0D, d1)).d().a(f); setMot(vec3d.x / 2.0D - vec3d1.x, this.onGround ? Math.min(0.4D, vec3d.y / 2.0D + f) : vec3d.y, vec3d.z / 2.0D - vec3d1.z); Vec3D currentMot = getMot(); Vector delta = new Vector(currentMot.x - vec3d.x, currentMot.y - vec3d.y, currentMot.z - vec3d.z); setMot(vec3d); if (knockingBackEntity == null || (new EntityKnockbackByEntityEvent((LivingEntity)getBukkitEntity(), (Entity)knockingBackEntity.getBukkitEntity(), f, delta)).callEvent()) setMot(vec3d.x + delta.getX(), vec3d.y + delta.getY(), vec3d.z + delta.getZ());  }  } @Nullable protected SoundEffect getSoundHurt(DamageSource damagesource) { return SoundEffects.ENTITY_GENERIC_HURT; } public final SoundEffect getDeathSoundEffect() { return getSoundDeath(); } @Nullable protected SoundEffect getSoundDeath() { return SoundEffects.ENTITY_GENERIC_DEATH; } protected SoundEffect getSoundFall(int i) { return (i > 4) ? SoundEffects.ENTITY_GENERIC_BIG_FALL : SoundEffects.ENTITY_GENERIC_SMALL_FALL; } protected SoundEffect c(ItemStack itemstack) { return itemstack.G(); } public SoundEffect d(ItemStack itemstack) { return itemstack.H(); } public void setOnGround(boolean flag) { super.setOnGround(flag); if (flag) this.by = Optional.empty();  } public Optional<BlockPosition> dq() { return this.by; } public boolean isClimbing() { if (isSpectator()) return false;  BlockPosition blockposition = getChunkCoordinates(); IBlockData iblockdata = dr(); Block block = iblockdata.getBlock(); if (block.a(TagsBlock.CLIMBABLE)) { this.by = Optional.of(blockposition); return true; }  if (block instanceof BlockTrapdoor && c(blockposition, iblockdata)) { this.by = Optional.of(blockposition); return true; }  return false; } public IBlockData dr() { return this.world.getType(getChunkCoordinates()); } private boolean c(BlockPosition blockposition, IBlockData iblockdata) { if (((Boolean)iblockdata.get(BlockTrapdoor.OPEN)).booleanValue()) { IBlockData iblockdata1 = this.world.getType(blockposition.down()); if (iblockdata1.a(Blocks.LADDER) && iblockdata1.get(BlockLadder.FACING) == iblockdata.get(BlockTrapdoor.FACING)) return true;  }  return false; } public boolean isAlive() { return (!this.dead && getHealth() > 0.0F); } public boolean b(float f, float f1) { boolean flag = super.b(f, f1); int i = e(f, f1); if (i > 0) { if (!damageEntity(DamageSource.FALL, i)) return true;  playSound(getSoundFall(i), 1.0F, 1.0F); playBlockStepSound(); return true; }  return flag; } protected int e(float f, float f1) { MobEffect mobeffect = getEffect(MobEffects.JUMP); float f2 = (mobeffect == null) ? 0.0F : (mobeffect.getAmplifier() + 1); return MathHelper.f((f - 3.0F - f2) * f1); } protected void playBlockStepSound() { if (!isSilent()) { int i = MathHelper.floor(locX()); int j = MathHelper.floor(locY() - 0.20000000298023224D); int k = MathHelper.floor(locZ()); IBlockData iblockdata = this.world.getType(new BlockPosition(i, j, k)); if (!iblockdata.isAir()) { SoundEffectType soundeffecttype = iblockdata.getStepSound(); playSound(soundeffecttype.g(), soundeffecttype.a() * 0.5F, soundeffecttype.b() * 0.75F); }  }  } public int getArmorStrength() { return MathHelper.floor(b(GenericAttributes.ARMOR)); } protected void damageArmor(DamageSource damagesource, float f) {} protected void damageShield(float f) {} protected float applyArmorModifier(DamageSource damagesource, float f) { if (!damagesource.ignoresArmor()) f = CombatMath.a(f, getArmorStrength(), (float)b(GenericAttributes.ARMOR_TOUGHNESS));  return f; } protected float applyMagicModifier(DamageSource damagesource, float f) { if (damagesource.isStarvation()) return f;  if (f <= 0.0F) return 0.0F;  int i = EnchantmentManager.a(getArmorItems(), damagesource); if (i > 0) f = CombatMath.a(f, i);  return f; } protected boolean damageEntity0(final DamageSource damagesource, float f) { if (!isInvulnerable(damagesource)) { boolean human = this instanceof EntityHuman; float originalDamage = f; Function<Double, Double> hardHat = new Function<Double, Double>() { public Double apply(Double f) { if ((damagesource == DamageSource.ANVIL || damagesource == DamageSource.FALLING_BLOCK) && !EntityLiving.this.getEquipment(EnumItemSlot.HEAD).isEmpty()) return Double.valueOf(-(f.doubleValue() - f.doubleValue() * 0.75D));  return Double.valueOf(-0.0D); } }
/*      */         ; float hardHatModifier = ((Double)hardHat.apply(Double.valueOf(f))).floatValue(); f += hardHatModifier; Function<Double, Double> blocking = new Function<Double, Double>() { public Double apply(Double f) { return Double.valueOf(-(EntityLiving.this.applyBlockingModifier(damagesource) ? f.doubleValue() : 0.0D)); } }
/* 3611 */         ; float blockingModifier = ((Double)blocking.apply(Double.valueOf(f))).floatValue(); f += blockingModifier; Function<Double, Double> armor = new Function<Double, Double>() { public Double apply(Double f) { return Double.valueOf(-(f.doubleValue() - EntityLiving.this.applyArmorModifier(damagesource, f.floatValue()))); } }; float armorModifier = ((Double)armor.apply(Double.valueOf(f))).floatValue(); f += armorModifier; Function<Double, Double> resistance = new Function<Double, Double>() { public Double apply(Double f) { if (!damagesource.isStarvation() && EntityLiving.this.hasEffect(MobEffects.RESISTANCE) && damagesource != DamageSource.OUT_OF_WORLD) { int i = (EntityLiving.this.getEffect(MobEffects.RESISTANCE).getAmplifier() + 1) * 5; int j = 25 - i; float f1 = f.floatValue() * j; return Double.valueOf(-(f.doubleValue() - (f1 / 25.0F))); }  return Double.valueOf(-0.0D); } }; float resistanceModifier = ((Double)resistance.apply(Double.valueOf(f))).floatValue(); f += resistanceModifier; Function<Double, Double> magic = new Function<Double, Double>() { public Double apply(Double f) { return Double.valueOf(-(f.doubleValue() - EntityLiving.this.applyMagicModifier(damagesource, f.floatValue()))); } }; float magicModifier = ((Double)magic.apply(Double.valueOf(f))).floatValue(); f += magicModifier; Function<Double, Double> absorption = new Function<Double, Double>() { public Double apply(Double f) { return Double.valueOf(-Math.max(f.doubleValue() - Math.max(f.doubleValue() - EntityLiving.this.getAbsorptionHearts(), 0.0D), 0.0D)); } }; float absorptionModifier = ((Double)absorption.apply(Double.valueOf(f))).floatValue(); EntityDamageEvent event = CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption); if (damagesource.getEntity() instanceof EntityHuman) if (damagesource.getEntity() instanceof EntityPlayer) { EntityPlayer player = (EntityPlayer)damagesource.getEntity(); if ((new PlayerAttackEntityCooldownResetEvent((Player)player.getBukkitEntity(), (Entity)getBukkitEntity(), player.getAttackCooldown(0.0F))).callEvent()) player.resetAttackCooldown();  } else { ((EntityHuman)damagesource.getEntity()).resetAttackCooldown(); }   if (event.isCancelled()) return false;  f = (float)event.getFinalDamage(); if (event.getDamage(EntityDamageEvent.DamageModifier.RESISTANCE) < 0.0D) { float f3 = (float)-event.getDamage(EntityDamageEvent.DamageModifier.RESISTANCE); if (f3 > 0.0F && f3 < 3.4028235E37F) if (this instanceof EntityPlayer) { ((EntityPlayer)this).a(StatisticList.DAMAGE_RESISTED, Math.round(f3 * 10.0F)); } else if (damagesource.getEntity() instanceof EntityPlayer) { ((EntityPlayer)damagesource.getEntity()).a(StatisticList.DAMAGE_DEALT_RESISTED, Math.round(f3 * 10.0F)); }   }  if ((damagesource == DamageSource.ANVIL || damagesource == DamageSource.FALLING_BLOCK) && getEquipment(EnumItemSlot.HEAD) != null) getEquipment(EnumItemSlot.HEAD).damage((int)(event.getDamage() * 4.0D + this.random.nextFloat() * event.getDamage() * 2.0D), this, entityliving -> entityliving.broadcastItemBreak(EnumItemSlot.HEAD));  if (!damagesource.ignoresArmor()) { float armorDamage = (float)(event.getDamage() + event.getDamage(EntityDamageEvent.DamageModifier.BLOCKING) + event.getDamage(EntityDamageEvent.DamageModifier.HARD_HAT)); damageArmor(damagesource, armorDamage); }  if (event.getDamage(EntityDamageEvent.DamageModifier.BLOCKING) < 0.0D) { this.world.broadcastEntityEffect(this, (byte)29); damageShield((float)-event.getDamage(EntityDamageEvent.DamageModifier.BLOCKING)); Entity entity = damagesource.j(); if (entity instanceof EntityLiving) shieldBlock((EntityLiving)entity);  }  absorptionModifier = (float)-event.getDamage(EntityDamageEvent.DamageModifier.ABSORPTION); setAbsorptionHearts(Math.max(getAbsorptionHearts() - absorptionModifier, 0.0F)); float f2 = absorptionModifier; if (f2 > 0.0F && f2 < 3.4028235E37F && this instanceof EntityHuman) ((EntityHuman)this).a(StatisticList.DAMAGE_ABSORBED, Math.round(f2 * 10.0F));  if (f2 > 0.0F && f2 < 3.4028235E37F && damagesource.getEntity() instanceof EntityPlayer) ((EntityPlayer)damagesource.getEntity()).a(StatisticList.DAMAGE_DEALT_ABSORBED, Math.round(f2 * 10.0F));  if (f > 0.0F || !human) { if (human) { ((EntityHuman)this).applyExhaustion(damagesource.getExhaustionCost()); if (f < 3.4028235E37F) ((EntityHuman)this).a(StatisticList.DAMAGE_TAKEN, Math.round(f * 10.0F));  }  float f3 = getHealth(); setHealth(f3 - f); getCombatTracker().trackDamage(damagesource, f3, f); if (!human) setAbsorptionHearts(getAbsorptionHearts() - f);  return true; }  if (event.getDamage(EntityDamageEvent.DamageModifier.BLOCKING) < 0.0D) { if (this instanceof EntityPlayer) { CriterionTriggers.h.a((EntityPlayer)this, damagesource, f, originalDamage, true); f2 = (float)-event.getDamage(EntityDamageEvent.DamageModifier.BLOCKING); if (f2 > 0.0F && f2 < 3.4028235E37F) ((EntityPlayer)this).a(StatisticList.DAMAGE_BLOCKED_BY_SHIELD, Math.round(originalDamage * 10.0F));  }  if (damagesource.getEntity() instanceof EntityPlayer) CriterionTriggers.g.a((EntityPlayer)damagesource.getEntity(), this, damagesource, f, originalDamage, true);  return false; }  return (originalDamage > 0.0F); }  return false; } public CombatTracker getCombatTracker() { return this.combatTracker; } @Nullable public EntityLiving getKillingEntity() { return (this.combatTracker.c() != null) ? this.combatTracker.c() : ((this.killer != null) ? this.killer : ((this.lastDamager != null) ? this.lastDamager : null)); } public final float getMaxHealth() { return (float)b(GenericAttributes.MAX_HEALTH); } public final int getArrowCount() { return ((Integer)this.datawatcher.<Integer>get(ARROWS_IN_BODY)).intValue(); } public final void setArrowCount(int i) { setArrowCount(i, false); } public final void setArrowCount(int i, boolean flag) { ArrowBodyCountChangeEvent event = CraftEventFactory.callArrowBodyCountChangeEvent(this, getArrowCount(), i, flag); if (event.isCancelled()) return;  this.datawatcher.set(ARROWS_IN_BODY, Integer.valueOf(event.getNewAmount())); } public final int dy() { return ((Integer)this.datawatcher.<Integer>get(bi)).intValue(); } public final void q(int i) { this.datawatcher.set(bi, Integer.valueOf(i)); } private int m() { return MobEffectUtil.a(this) ? (6 - 1 + MobEffectUtil.b(this)) : (hasEffect(MobEffects.SLOWER_DIG) ? (6 + (1 + getEffect(MobEffects.SLOWER_DIG).getAmplifier()) * 2) : 6); } public void swingHand(EnumHand enumhand) { swingHand(enumhand, false); } public void swingHand(EnumHand enumhand, boolean flag) { if (!this.ai || this.ak >= m() / 2 || this.ak < 0) { this.ak = -1; this.ai = true; this.aj = enumhand; if (this.world instanceof WorldServer) { PacketPlayOutAnimation packetplayoutanimation = new PacketPlayOutAnimation(this, (enumhand == EnumHand.MAIN_HAND) ? 0 : 3); ChunkProviderServer chunkproviderserver = ((WorldServer)this.world).getChunkProvider(); if (flag) { chunkproviderserver.broadcastIncludingSelf(this, packetplayoutanimation); } else { chunkproviderserver.broadcast(this, packetplayoutanimation); }  }  }  } protected void am() { damageEntity(DamageSource.OUT_OF_WORLD, 4.0F); } protected void dz() { int i = m(); if (this.ai) { this.ak++; if (this.ak >= i) { this.ak = 0; this.ai = false; }  } else { this.ak = 0; }  this.as = this.ak / i; } @Nullable public AttributeModifiable getAttributeInstance(AttributeBase attributebase) { return getAttributeMap().a(attributebase); } public int getShieldBlockingDelay() { return this.shieldBlockingDelay; }
/*      */   public double b(AttributeBase attributebase) { return getAttributeMap().c(attributebase); }
/*      */   public double c(AttributeBase attributebase) { return getAttributeMap().d(attributebase); }
/*      */   public AttributeMapBase getAttributeMap() { return this.attributeMap; }
/* 3615 */   public EnumMonsterType getMonsterType() { return EnumMonsterType.UNDEFINED; } public ItemStack getItemInMainHand() { return getEquipment(EnumItemSlot.MAINHAND); } public ItemStack getItemInOffHand() { return getEquipment(EnumItemSlot.OFFHAND); } public boolean a(Item item) { return a(item1 -> (item1 == item)); } public boolean a(Predicate<Item> predicate) { return (predicate.test(getItemInMainHand().getItem()) || predicate.test(getItemInOffHand().getItem())); } public final ItemStack getItemInHand(EnumHand enumhand) { return b(enumhand); } public ItemStack b(EnumHand enumhand) { if (enumhand == EnumHand.MAIN_HAND) return getEquipment(EnumItemSlot.MAINHAND);  if (enumhand == EnumHand.OFF_HAND) return getEquipment(EnumItemSlot.OFFHAND);  throw new IllegalArgumentException("Invalid hand " + enumhand); } public void a(EnumHand enumhand, ItemStack itemstack) { if (enumhand == EnumHand.MAIN_HAND) { setSlot(EnumItemSlot.MAINHAND, itemstack); } else { if (enumhand != EnumHand.OFF_HAND) throw new IllegalArgumentException("Invalid hand " + enumhand);  setSlot(EnumItemSlot.OFFHAND, itemstack); }  } public boolean a(EnumItemSlot enumitemslot) { return !getEquipment(enumitemslot).isEmpty(); } public float dE() { Iterable<ItemStack> iterable = getArmorItems(); int i = 0; int j = 0; for (Iterator<ItemStack> iterator = iterable.iterator(); iterator.hasNext(); i++) { ItemStack itemstack = iterator.next(); if (!itemstack.isEmpty()) j++;  }  return (i > 0) ? (j / i) : 0.0F; } public void setSprinting(boolean flag) { super.setSprinting(flag); AttributeModifiable attributemodifiable = getAttributeInstance(GenericAttributes.MOVEMENT_SPEED); if (attributemodifiable.a(b) != null) attributemodifiable.removeModifier(d);  if (flag) attributemodifiable.b(d);  } public final float getDeathSoundVolume() { return getSoundVolume(); } protected float getSoundVolume() { return 1.0F; } public float getSoundPitch() { return dG(); } protected float dG() { return isBaby() ? ((this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.5F) : ((this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F); } protected boolean isFrozen() { return dk(); } public void collide(Entity entity) { if (!isSleeping()) super.collide(entity);  } private void a(Entity entity) { Vec3D vec3d; if (!entity.dead && !this.world.getType(entity.getChunkCoordinates()).getBlock().a(TagsBlock.PORTALS)) { vec3d = entity.b(this); } else { vec3d = new Vec3D(entity.locX(), entity.locY() + entity.getHeight(), entity.locZ()); }  enderTeleportTo(vec3d.x, vec3d.y, vec3d.z); } protected float dI() { return 0.42F * getBlockJumpFactor(); } protected void jump() { float f = dI(); if (hasEffect(MobEffects.JUMP)) f += 0.1F * (getEffect(MobEffects.JUMP).getAmplifier() + 1);  Vec3D vec3d = getMot(); setMot(vec3d.x, f, vec3d.z); if (isSprinting()) { float f1 = this.yaw * 0.017453292F; setMot(getMot().add((-MathHelper.sin(f1) * 0.2F), 0.0D, (MathHelper.cos(f1) * 0.2F))); }  this.impulse = true; } protected void c(Tag<FluidType> tag) { setMot(getMot().add(0.0D, 0.03999999910593033D, 0.0D)); } protected float dL() { return 0.8F; } public boolean a(FluidType fluidtype) { return false; } public void g(Vec3D vec3d) { if (doAITick() || cr()) { double d0 = 0.08D; boolean flag = ((getMot()).y <= 0.0D); if (flag && hasEffect(MobEffects.SLOW_FALLING)) { d0 = 0.01D; this.fallDistance = 0.0F; }  Fluid fluid = this.world.getFluid(getChunkCoordinates()); if (isInWater() && cS() && !a(fluid.getType())) { double d1 = locY(); float f = isSprinting() ? 0.9F : dL(); float f1 = 0.02F; float f2 = EnchantmentManager.e(this); if (f2 > 3.0F) f2 = 3.0F;  if (!this.onGround) f2 *= 0.5F;  if (f2 > 0.0F) { f += (0.54600006F - f) * f2 / 3.0F; f1 += (dM() - f1) * f2 / 3.0F; }  if (hasEffect(MobEffects.DOLPHINS_GRACE)) f = 0.96F;  a(f1, vec3d); move(EnumMoveType.SELF, getMot()); Vec3D vec3d1 = getMot(); if (this.positionChanged && isClimbing()) vec3d1 = new Vec3D(vec3d1.x, 0.2D, vec3d1.z);  setMot(vec3d1.d(f, 0.800000011920929D, f)); Vec3D vec3d2 = a(d0, flag, getMot()); setMot(vec3d2); if (this.positionChanged && e(vec3d2.x, vec3d2.y + 0.6000000238418579D - locY() + d1, vec3d2.z)) setMot(vec3d2.x, 0.30000001192092896D, vec3d2.z);  } else if (aP() && cS() && !a(fluid.getType())) { double d1 = locY(); a(0.02F, vec3d); move(EnumMoveType.SELF, getMot()); if (b(TagsFluid.LAVA) <= cw()) { setMot(getMot().d(0.5D, 0.800000011920929D, 0.5D)); Vec3D vec3D = a(d0, flag, getMot()); setMot(vec3D); } else { setMot(getMot().a(0.5D)); }  if (!isNoGravity()) setMot(getMot().add(0.0D, -d0 / 4.0D, 0.0D));  Vec3D vec3d3 = getMot(); if (this.positionChanged && e(vec3d3.x, vec3d3.y + 0.6000000238418579D - locY() + d1, vec3d3.z)) setMot(vec3d3.x, 0.30000001192092896D, vec3d3.z);  } else if (isGliding()) { Vec3D vec3d4 = getMot(); if (vec3d4.y > -0.5D) this.fallDistance = 1.0F;  Vec3D vec3d5 = getLookDirection(); float f = this.pitch * 0.017453292F; double d2 = Math.sqrt(vec3d5.x * vec3d5.x + vec3d5.z * vec3d5.z); double d3 = Math.sqrt(c(vec3d4)); double d4 = vec3d5.f(); float f3 = MathHelper.cos(f); f3 = (float)(f3 * f3 * Math.min(1.0D, d4 / 0.4D)); vec3d4 = getMot().add(0.0D, d0 * (-1.0D + f3 * 0.75D), 0.0D); if (vec3d4.y < 0.0D && d2 > 0.0D) { double d5 = vec3d4.y * -0.1D * f3; vec3d4 = vec3d4.add(vec3d5.x * d5 / d2, d5, vec3d5.z * d5 / d2); }  if (f < 0.0F && d2 > 0.0D) { double d5 = d3 * -MathHelper.sin(f) * 0.04D; vec3d4 = vec3d4.add(-vec3d5.x * d5 / d2, d5 * 3.2D, -vec3d5.z * d5 / d2); }  if (d2 > 0.0D) vec3d4 = vec3d4.add((vec3d5.x / d2 * d3 - vec3d4.x) * 0.1D, 0.0D, (vec3d5.z / d2 * d3 - vec3d4.z) * 0.1D);  setMot(vec3d4.d(0.9900000095367432D, 0.9800000190734863D, 0.9900000095367432D)); move(EnumMoveType.SELF, getMot()); if (this.positionChanged && !this.world.isClientSide) { double d5 = Math.sqrt(c(getMot())); double d6 = d3 - d5; float f4 = (float)(d6 * 10.0D - 3.0D); if (f4 > 0.0F) { playSound(getSoundFall((int)f4), 1.0F, 1.0F); damageEntity(DamageSource.FLY_INTO_WALL, f4); }  }  if (this.onGround && !this.world.isClientSide && getFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) setFlag(7, false);  } else { BlockPosition blockposition = ar(); float f5 = this.world.getType(blockposition).getBlock().getFrictionFactor(); float f = this.onGround ? (f5 * 0.91F) : 0.91F; Vec3D vec3d6 = a(vec3d, f5); double d7 = vec3d6.y; if (hasEffect(MobEffects.LEVITATION)) { d7 += (0.05D * (getEffect(MobEffects.LEVITATION).getAmplifier() + 1) - vec3d6.y) * 0.2D; this.fallDistance = 0.0F; } else if (this.world.isClientSide && !this.world.isLoaded(blockposition)) { if (locY() > 0.0D) { d7 = -0.1D; } else { d7 = 0.0D; }  } else if (!isNoGravity()) { d7 -= d0; }  setMot(vec3d6.x * f, d7 * 0.9800000190734863D, vec3d6.z * f); }  }  a(this, this instanceof EntityBird); } public void a(EntityLiving entityliving, boolean flag) { entityliving.au = entityliving.av; double d0 = entityliving.locX() - entityliving.lastX; double d1 = flag ? (entityliving.locY() - entityliving.lastY) : 0.0D; double d2 = entityliving.locZ() - entityliving.lastZ; float f = MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 4.0F; if (f > 1.0F) f = 1.0F;  entityliving.av += (f - entityliving.av) * 0.4F; entityliving.aw += entityliving.av; } public Vec3D a(Vec3D vec3d, float f) { a(t(f), vec3d); setMot(i(getMot())); move(EnumMoveType.SELF, getMot()); Vec3D vec3d1 = getMot(); if ((this.positionChanged || this.jumping) && isClimbing()) vec3d1 = new Vec3D(vec3d1.x, 0.2D, vec3d1.z);  return vec3d1; } public Vec3D a(double d0, boolean flag, Vec3D vec3d) { if (!isNoGravity() && !isSprinting()) { double d1; if (flag && Math.abs(vec3d.y - 0.005D) >= 0.003D && Math.abs(vec3d.y - d0 / 16.0D) < 0.003D) { d1 = -0.003D; } else { d1 = vec3d.y - d0 / 16.0D; }  return new Vec3D(vec3d.x, d1, vec3d.z); }  return vec3d; } private Vec3D i(Vec3D vec3d) { if (isClimbing()) { this.fallDistance = 0.0F; float f = 0.15F; double d0 = MathHelper.a(vec3d.x, -0.15000000596046448D, 0.15000000596046448D); double d1 = MathHelper.a(vec3d.z, -0.15000000596046448D, 0.15000000596046448D); double d2 = Math.max(vec3d.y, -0.15000000596046448D); if (d2 < 0.0D && !dr().a(Blocks.SCAFFOLDING) && ed() && this instanceof EntityHuman) d2 = 0.0D;  vec3d = new Vec3D(d0, d2, d1); }  return vec3d; } private float t(float f) { return this.onGround ? (dM() * 0.21600002F / f * f * f) : this.aE; } public float dM() { return this.bu; } public void q(float f) { this.bu = f; } public boolean attackEntity(Entity entity) { z(entity); return false; } public void tick() { super.tick(); t(); v(); if (!this.world.isClientSide) { int i = getArrowCount(); if (i > 0) { if (this.arrowCooldown <= 0) this.arrowCooldown = 20 * (30 - i);  this.arrowCooldown--; if (this.arrowCooldown <= 0) setArrowCount(i - 1);  }  int j = dy(); if (j > 0) { if (this.am <= 0) this.am = 20 * (30 - j);  this.am--; if (this.am <= 0) q(j - 1);  }  p(); if (this.ticksLived % 20 == 0) getCombatTracker().g();  if (!this.glowing) { boolean flag = hasEffect(MobEffects.GLOWING); if (getFlag(6) != flag) setFlag(6, flag);  }  if (isSleeping() && !x()) entityWakeup();  }  movementTick(); double d0 = locX() - this.lastX; double d1 = locZ() - this.lastZ; float f = (float)(d0 * d0 + d1 * d1); float f1 = this.aA; float f2 = 0.0F; this.aJ = this.aK; float f3 = 0.0F; if (f > 0.0025000002F) { f3 = 1.0F; f2 = (float)Math.sqrt(f) * 3.0F; float f4 = (float)MathHelper.d(d1, d0) * 57.295776F - 90.0F; float f5 = MathHelper.e(MathHelper.g(this.yaw) - f4); if (95.0F < f5 && f5 < 265.0F) { f1 = f4 - 180.0F; } else { f1 = f4; }  }  if (this.as > 0.0F) f1 = this.yaw;  if (!this.onGround) f3 = 0.0F;  this.aK += (f3 - this.aK) * 0.3F; this.world.getMethodProfiler().enter("headTurn"); f2 = f(f1, f2); this.world.getMethodProfiler().exit(); this.world.getMethodProfiler().enter("rangeChecks"); while (this.yaw - this.lastYaw < -180.0F) this.lastYaw -= 360.0F;  while (this.yaw - this.lastYaw >= 180.0F) this.lastYaw += 360.0F;  while (this.aA - this.aB < -180.0F) this.aB -= 360.0F;  while (this.aA - this.aB >= 180.0F) this.aB += 360.0F;  while (this.pitch - this.lastPitch < -180.0F) this.lastPitch -= 360.0F;  while (this.pitch - this.lastPitch >= 180.0F) this.lastPitch += 360.0F;  while (this.aC - this.aD < -180.0F) this.aD -= 360.0F;  while (this.aC - this.aD >= 180.0F) this.aD += 360.0F;  this.world.getMethodProfiler().exit(); this.aL += f2; if (isGliding()) { this.be++; } else { this.be = 0; }  if (isSleeping()) this.pitch = 0.0F;  } public final void updateEntityEquipment() { p(); } private void p() { Map<EnumItemSlot, ItemStack> map = q(); if (map != null) { a(map); if (!map.isEmpty()) b(map);  }  } @Nullable private Map<EnumItemSlot, ItemStack> q() { Map<EnumItemSlot, ItemStack> map = null; EnumItemSlot[] aenumitemslot = EnumItemSlot.values(); int i = aenumitemslot.length; for (int j = 0; j < i; ) { ItemStack itemstack; EnumItemSlot enumitemslot = aenumitemslot[j]; switch (enumitemslot.a()) { case MAINHAND: itemstack = e(enumitemslot); break;case OFFHAND: itemstack = d(enumitemslot); break;default: j++; continue; }  ItemStack itemstack1 = getEquipment(enumitemslot); if (!ItemStack.matches(itemstack1, itemstack)) { if (this instanceof EntityPlayer && enumitemslot.getType() == EnumItemSlot.Function.ARMOR) { ItemStack oldItem = CraftItemStack.asBukkitCopy(itemstack); ItemStack newItem = CraftItemStack.asBukkitCopy(itemstack1); (new PlayerArmorChangeEvent((Player)getBukkitEntity(), PlayerArmorChangeEvent.SlotType.valueOf(enumitemslot.name()), oldItem, newItem)).callEvent(); }  if (map == null) map = Maps.newEnumMap(EnumItemSlot.class);  map.put(enumitemslot, itemstack1); if (!itemstack.isEmpty()) getAttributeMap().a(itemstack.a(enumitemslot));  if (!itemstack1.isEmpty()) getAttributeMap().b(itemstack1.a(enumitemslot));  }  }  return map; } private void a(Map<EnumItemSlot, ItemStack> map) { ItemStack itemstack = map.get(EnumItemSlot.MAINHAND); ItemStack itemstack1 = map.get(EnumItemSlot.OFFHAND); if (itemstack != null && itemstack1 != null && ItemStack.matches(itemstack, e(EnumItemSlot.OFFHAND)) && ItemStack.matches(itemstack1, e(EnumItemSlot.MAINHAND))) { ((WorldServer)this.world).getChunkProvider().broadcast(this, new PacketPlayOutEntityStatus(this, (byte)55)); map.remove(EnumItemSlot.MAINHAND); map.remove(EnumItemSlot.OFFHAND); c(EnumItemSlot.MAINHAND, itemstack.cloneItemStack()); c(EnumItemSlot.OFFHAND, itemstack1.cloneItemStack()); }  } private void b(Map<EnumItemSlot, ItemStack> map) { List<Pair<EnumItemSlot, ItemStack>> list = Lists.newArrayListWithCapacity(map.size()); map.forEach((enumitemslot, itemstack) -> { ItemStack itemstack1 = itemstack.cloneItemStack(); list.add(Pair.of(enumitemslot, itemstack1)); switch (enumitemslot.a()) { case MAINHAND: c(enumitemslot, itemstack1); break;case OFFHAND: b(enumitemslot, itemstack1); break; }  }); ((WorldServer)this.world).getChunkProvider().broadcast(this, new PacketPlayOutEntityEquipment(getId(), list)); } private ItemStack d(EnumItemSlot enumitemslot) { return this.bo.get(enumitemslot.b()); } private void b(EnumItemSlot enumitemslot, ItemStack itemstack) { this.bo.set(enumitemslot.b(), itemstack); } private ItemStack e(EnumItemSlot enumitemslot) { return this.bn.get(enumitemslot.b()); } private void c(EnumItemSlot enumitemslot, ItemStack itemstack) { this.bn.set(enumitemslot.b(), itemstack); } protected float f(float f, float f1) { float f2 = MathHelper.g(f - this.aA); this.aA += f2 * 0.3F; float f3 = MathHelper.g(this.yaw - this.aA); boolean flag = (f3 < -90.0F || f3 >= 90.0F); if (f3 < -75.0F) f3 = -75.0F;  if (f3 >= 75.0F) f3 = 75.0F;  this.aA = this.yaw - f3; if (f3 * f3 > 2500.0F) this.aA += f3 * 0.2F;  if (flag) f1 *= -1.0F;  return f1; } public void movementTick() { if (this.jumpTicks > 0) this.jumpTicks--;  if (cr()) { this.aU = 0; c(locX(), locY(), locZ()); }  if (this.aU > 0) { double d0 = locX() + (this.aV - locX()) / this.aU; double d1 = locY() + (this.aW - locY()) / this.aU; double d2 = locZ() + (this.aX - locZ()) / this.aU; double d3 = MathHelper.g(this.aY - this.yaw); this.yaw = (float)(this.yaw + d3 / this.aU); this.pitch = (float)(this.pitch + (this.aZ - this.pitch) / this.aU); this.aU--; setPosition(d0, d1, d2); setYawPitch(this.yaw, this.pitch); } else if (!doAITick()) { setMot(getMot().a(0.98D)); }  if (this.bb > 0) { this.aC = (float)(this.aC + MathHelper.g(this.ba - this.aC) / this.bb); this.bb--; }  Vec3D vec3d = getMot(); double d4 = vec3d.x; double d5 = vec3d.y; double d6 = vec3d.z; if (Math.abs(vec3d.x) < 0.003D) d4 = 0.0D;  if (Math.abs(vec3d.y) < 0.003D) d5 = 0.0D;  if (Math.abs(vec3d.z) < 0.003D) d6 = 0.0D;  setMot(d4, d5, d6); this.world.getMethodProfiler().enter("ai"); if (isFrozen()) { this.jumping = false; this.aR = 0.0F; this.aT = 0.0F; } else if (doAITick()) { this.world.getMethodProfiler().enter("newAi"); doTick(); this.world.getMethodProfiler().exit(); }  this.world.getMethodProfiler().exit(); this.world.getMethodProfiler().enter("jump"); if (this.jumping && cS()) { double d7; if (aP()) { d7 = b(TagsFluid.LAVA); } else { d7 = b(TagsFluid.WATER); }  boolean flag = (isInWater() && d7 > 0.0D); double d8 = cw(); if (flag && (!this.onGround || d7 > d8)) { c(TagsFluid.WATER); } else if (aP() && (!this.onGround || d7 > d8)) { c(TagsFluid.LAVA); } else if ((this.onGround || (flag && d7 <= d8)) && this.jumpTicks == 0) { if ((new EntityJumpEvent((LivingEntity)getBukkitLivingEntity())).callEvent()) { jump(); this.jumpTicks = 10; } else { setJumping(false); }  }  } else { this.jumpTicks = 0; }  this.world.getMethodProfiler().exit(); this.world.getMethodProfiler().enter("travel"); this.aR *= 0.98F; this.aT *= 0.98F; r(); AxisAlignedBB axisalignedbb = getBoundingBox(); g(new Vec3D(this.aR, this.aS, this.aT)); this.world.getMethodProfiler().exit(); this.world.getMethodProfiler().enter("push"); if (this.bf > 0) { this.bf--; a(axisalignedbb, getBoundingBox()); }  collideNearby(); this.world.getMethodProfiler().exit(); if (!this.world.isClientSide && dN() && aF()) damageEntity(DamageSource.DROWN, 1.0F);  } public boolean dN() { return false; } private void r() { boolean flag = getFlag(7); if (flag && !this.onGround && !isPassenger() && !hasEffect(MobEffects.LEVITATION)) { ItemStack itemstack = getEquipment(EnumItemSlot.CHEST); if (itemstack.getItem() == Items.ELYTRA && ItemElytra.d(itemstack)) { flag = true; if (!this.world.isClientSide && (this.be + 1) % 20 == 0) itemstack.damage(1, this, entityliving -> entityliving.broadcastItemBreak(EnumItemSlot.CHEST));  } else { flag = false; }  } else { flag = false; }  if (!this.world.isClientSide && flag != getFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, flag).isCancelled()) setFlag(7, flag);  } protected void doTick() {} protected void collideNearby() { int i = this.world.getGameRules().getInt(GameRules.MAX_ENTITY_CRAMMING); if (i <= 0 && this.world.paperConfig.maxCollisionsPerEntity <= 0) return;  List<Entity> list = CachedLists.getTempGetEntitiesList(); this.world.getEntities(this, getBoundingBox(), IEntitySelector.a(this), list); try { if (!list.isEmpty()) { if (i > 0 && list.size() > i - 1 && this.random.nextInt(4) == 0) { int m = 0; for (int k = 0; k < list.size(); k++) { if (!((Entity)list.get(k)).isPassenger()) m++;  }  if (m > i - 1) damageEntity(DamageSource.CRAMMING, 6.0F);  }  this.numCollisions = Math.max(0, this.numCollisions - this.world.paperConfig.maxCollisionsPerEntity); for (int j = 0; j < list.size() && this.numCollisions < this.world.paperConfig.maxCollisionsPerEntity; j++) { Entity entity = list.get(j); entity.numCollisions++; this.numCollisions++; C(entity); }  }  } finally { CachedLists.returnTempGetEntitiesList(list); }  } protected void a(AxisAlignedBB axisalignedbb, AxisAlignedBB axisalignedbb1) { AxisAlignedBB axisalignedbb2 = axisalignedbb.b(axisalignedbb1); List<Entity> list = this.world.getEntities(this, axisalignedbb2); if (!list.isEmpty()) { for (int i = 0; i < list.size(); i++) { Entity entity = list.get(i); if (entity instanceof EntityLiving) { g((EntityLiving)entity); this.bf = 0; setMot(getMot().a(-0.2D)); break; }  }  } else if (this.positionChanged) { this.bf = 0; }  if (!this.world.isClientSide && this.bf <= 0) c(4, false);  } protected void C(Entity entity) { entity.collide(this); } protected void g(EntityLiving entityliving) {} public void r(int i) { this.bf = i; if (!this.world.isClientSide) c(4, true);  } public boolean isRiptiding() { return ((((Byte)this.datawatcher.<Byte>get(ag)).byteValue() & 0x4) != 0); } public void stopRiding() { stopRiding(false); } public void stopRiding(boolean suppressCancellation) { Entity entity = getVehicle(); super.stopRiding(suppressCancellation); if (entity != null && entity != getVehicle() && !this.world.isClientSide && entity.valid) a(entity);  } public void passengerTick() { super.passengerTick(); this.aJ = this.aK; this.aK = 0.0F; this.fallDistance = 0.0F; } public void setJumping(boolean flag) { this.jumping = flag; } public void a(EntityItem entityitem) { EntityHuman entityhuman = (entityitem.getThrower() != null) ? this.world.b(entityitem.getThrower()) : null; if (entityhuman instanceof EntityPlayer) CriterionTriggers.O.a((EntityPlayer)entityhuman, entityitem.getItemStack(), this);  } public void receive(Entity entity, int i) { if (!entity.dead && !this.world.isClientSide && (entity instanceof EntityItem || entity instanceof EntityArrow || entity instanceof EntityExperienceOrb)) ((WorldServer)this.world).getChunkProvider().broadcast(entity, new PacketPlayOutCollect(entity.getId(), getId(), i));  } public boolean hasLineOfSight(Entity entity) { if (this.world != entity.world) return false;  Vec3D vec3d = new Vec3D(locX(), getHeadY(), locZ()); Vec3D vec3d1 = new Vec3D(entity.locX(), entity.getHeadY(), entity.locZ()); return (this.world.rayTrace(new RayTrace(vec3d, vec3d1, RayTrace.BlockCollisionOption.COLLIDER, RayTrace.FluidCollisionOption.NONE, this)).getType() == MovingObjectPosition.EnumMovingObjectType.MISS); } public float h(float f) { return (f == 1.0F) ? this.aC : MathHelper.g(f, this.aD, this.aC); } public boolean doAITick() { return !this.world.isClientSide; } public boolean isInteractable() { return (!this.dead && this.collides); } public boolean isCollidable() { return (isAlive() && !isSpectator() && !isClimbing() && this.collides); } public boolean canCollideWith(Entity entity) { return (isCollidable() && this.collides != this.collidableExemptions.contains(entity.getUniqueID())); } protected void velocityChanged() { this.velocityChanged = (this.random.nextDouble() >= b(GenericAttributes.KNOCKBACK_RESISTANCE)); } public float getHeadRotation() { return this.aC; } public void setHeadRotation(float f) { this.aC = f; } public void n(float f) { this.aA = f; } protected Vec3D a(EnumDirection.EnumAxis enumdirection_enumaxis, BlockUtil.Rectangle blockutil_rectangle) { return h(super.a(enumdirection_enumaxis, blockutil_rectangle)); } public static Vec3D h(Vec3D vec3d) { return new Vec3D(vec3d.x, vec3d.y, 0.0D); } public float getAbsorptionHearts() { return this.bw; } public void setAbsorptionHearts(float f) { if (f < 0.0F || Float.isNaN(f)) f = 0.0F;  this.bw = f; } public void enterCombat() {} public void exitCombat() {} protected void dT() { this.updateEffects = true; } public boolean isHandRaised() { return ((((Byte)this.datawatcher.<Byte>get(ag)).byteValue() & 0x1) > 0); } public EnumHand getRaisedHand() { return ((((Byte)this.datawatcher.<Byte>get(ag)).byteValue() & 0x2) > 0) ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND; } private void t() { if (isHandRaised()) if (ItemStack.d(b(getRaisedHand()), this.activeItem)) { this.activeItem = b(getRaisedHand()); this.activeItem.b(this.world, this, dY()); if (u()) b(this.activeItem, 5);  boolean shouldLagCompensate = (this.activeItem.getItem().isFood() && this.eatStartTime != -1L && System.nanoTime() - this.eatStartTime > ((1 + this.totalEatTimeTicks) * 50 * 1000000)); if ((--this.bd == 0 || shouldLagCompensate) && !this.world.isClientSide && !this.activeItem.m()) { setEatTimeTicks(0); s(); }  } else { clearActiveItem(); }   } private boolean u() { int i = dY(); FoodInfo foodinfo = this.activeItem.getItem().getFoodInfo(); boolean flag = (foodinfo != null && foodinfo.e()); int j = flag | ((i <= this.activeItem.k() - 7) ? 1 : 0); return (j != 0 && i % 4 == 0); } private void v() { this.bC = this.bB; if (bB()) { this.bB = Math.min(1.0F, this.bB + 0.09F); } else { this.bB = Math.max(0.0F, this.bB - 0.09F); }  } protected void c(int i, boolean flag) { int j; byte b0 = ((Byte)this.datawatcher.<Byte>get(ag)).byteValue(); if (flag) { j = b0 | i; } else { j = b0 & (i ^ 0xFFFFFFFF); }  this.datawatcher.set(ag, Byte.valueOf((byte)j)); } public void c(EnumHand enumhand) { updateActiveItem(enumhand, false); } public void updateActiveItem(EnumHand enumhand, boolean forceUpdate) { ItemStack itemstack = b(enumhand); if ((!itemstack.isEmpty() && !isHandRaised()) || forceUpdate) { this.activeItem = itemstack; this.bd = this.totalEatTimeTicks = itemstack.k(); this.eatStartTime = System.nanoTime(); if (!this.world.isClientSide) { c(1, true); c(2, (enumhand == EnumHand.OFF_HAND)); }  }  } public void a(DataWatcherObject<?> datawatcherobject) { super.a(datawatcherobject); if (bj.equals(datawatcherobject)) { if (this.world.isClientSide) getBedPosition().ifPresent(this::a);  } else if (ag.equals(datawatcherobject) && this.world.isClientSide) { if (isHandRaised() && this.activeItem.isEmpty()) { this.activeItem = b(getRaisedHand()); if (!this.activeItem.isEmpty()) this.bd = this.activeItem.k();  } else if (!isHandRaised() && !this.activeItem.isEmpty()) { this.activeItem = ItemStack.b; this.bd = this.totalEatTimeTicks = 0; this.eatStartTime = -1L; }  }  } public void a(ArgumentAnchor.Anchor argumentanchor_anchor, Vec3D vec3d) { super.a(argumentanchor_anchor, vec3d); this.aD = this.aC; this.aA = this.aC; this.aB = this.aA; } protected void b(ItemStack itemstack, int i) { if (!itemstack.isEmpty() && isHandRaised()) { if (itemstack.l() == EnumAnimation.DRINK) playSound(c(itemstack), 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);  if (itemstack.l() == EnumAnimation.EAT) { a(itemstack, i); playSound(d(itemstack), 0.5F + 0.5F * this.random.nextInt(2), (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F); }  }  } private void a(ItemStack itemstack, int i) { for (int j = 0; j < i; j++) { Vec3D vec3d = new Vec3D((this.random.nextFloat() - 0.5D) * 0.1D, Math.random() * 0.1D + 0.1D, 0.0D); vec3d = vec3d.a(-this.pitch * 0.017453292F); vec3d = vec3d.b(-this.yaw * 0.017453292F); double d0 = -this.random.nextFloat() * 0.6D - 0.3D; Vec3D vec3d1 = new Vec3D((this.random.nextFloat() - 0.5D) * 0.3D, d0, 0.6D); vec3d1 = vec3d1.a(-this.pitch * 0.017453292F); vec3d1 = vec3d1.b(-this.yaw * 0.017453292F); vec3d1 = vec3d1.add(locX(), getHeadY(), locZ()); this.world.addParticle(new ParticleParamItem(Particles.ITEM, itemstack), vec3d1.x, vec3d1.y, vec3d1.z, vec3d.x, vec3d.y + 0.05D, vec3d.z); }  } protected void s() { EnumHand enumhand = getRaisedHand(); if (!this.activeItem.equals(b(enumhand))) { releaseActiveItem(); } else if (!this.activeItem.isEmpty() && isHandRaised()) { ItemStack itemstack; updateActiveItem(getRaisedHand(), true); b(this.activeItem, 16); PlayerItemConsumeEvent event = null; if (this instanceof EntityPlayer) { ItemStack craftItem = CraftItemStack.asBukkitCopy(this.activeItem); event = new PlayerItemConsumeEvent((Player)getBukkitEntity(), craftItem); this.world.getServer().getPluginManager().callEvent((Event)event); if (event.isCancelled()) { ((EntityPlayer)this).getBukkitEntity().updateInventory(); ((EntityPlayer)this).getBukkitEntity().updateScaledHealth(); return; }  itemstack = craftItem.equals(event.getItem()) ? this.activeItem.a(this.world, this) : CraftItemStack.asNMSCopy(event.getItem()).a(this.world, this); } else { itemstack = this.activeItem.a(this.world, this); }  ItemStack defaultReplacement = itemstack; if (event != null && event.getReplacement() != null) itemstack = CraftItemStack.asNMSCopy(event.getReplacement());  if (itemstack != this.activeItem) a(enumhand, itemstack);  clearActiveItem(); if (this instanceof EntityPlayer) ((EntityPlayer)this).getBukkitEntity().updateInventory();  }  } public ItemStack getActiveItem() { return this.activeItem; } public int getItemUseRemainingTime() { return dY(); } public int dY() { return this.bd; } public int getHandRaisedTime() { return dZ(); } public int dZ() { return isHandRaised() ? (this.activeItem.k() - dY()) : 0; } public void releaseActiveItem() { if (!this.activeItem.isEmpty()) { this.activeItem.a(this.world, this, dY()); if (this.activeItem.m()) t();  }  clearActiveItem(); } public void clearActiveItem() { if (!this.world.isClientSide) c(1, false);  this.activeItem = ItemStack.b; this.bd = this.totalEatTimeTicks = 0; this.eatStartTime = -1L; } public boolean isBlocking() { if (isHandRaised() && !this.activeItem.isEmpty()) { Item item = this.activeItem.getItem(); return (item.d_(this.activeItem) != EnumAnimation.BLOCK) ? false : ((item.e_(this.activeItem) - this.bd >= getShieldBlockingDelay())); }  return false; } public boolean ed() { return isSneaking(); } public boolean isGliding() { return getFlag(7); } public boolean bB() { return (super.bB() || (!isGliding() && getPose() == EntityPose.FALL_FLYING)); } public boolean a(double d0, double d1, double d2, boolean flag) { double d3 = locX(); double d4 = locY(); double d5 = locZ(); double d6 = d1; boolean flag1 = false; BlockPosition blockposition = new BlockPosition(d0, d1, d2); World world = this.world; if (world.isLoaded(blockposition)) { boolean flag2 = false; while (!flag2 && blockposition.getY() > 0) { BlockPosition blockposition1 = blockposition.down(); IBlockData iblockdata = world.getType(blockposition1); if (iblockdata.getMaterial().isSolid()) { flag2 = true; continue; }  d6--; blockposition = blockposition1; }  if (flag2) { EntityTeleportEvent teleport = new EntityTeleportEvent((Entity)getBukkitEntity(), new Location((World)this.world.getWorld(), d3, d4, d5), new Location((World)this.world.getWorld(), d0, d6, d2)); this.world.getServer().getPluginManager().callEvent((Event)teleport); if (!teleport.isCancelled()) { Location to = teleport.getTo(); enderTeleportTo(to.getX(), to.getY(), to.getZ()); if (world.getCubes(this) && !world.containsLiquid(getBoundingBox())) flag1 = true;  }  }  }  if (!flag1) { enderTeleportTo(d3, d4, d5); return false; }  if (flag) world.broadcastEntityEffect(this, (byte)46);  if (this instanceof EntityCreature) ((EntityCreature)this).getNavigation().o();  return true; } public boolean eg() { return true; } public boolean eh() { return true; } public boolean e(ItemStack itemstack) { return false; } public Packet<?> P() { return new PacketPlayOutSpawnEntityLiving(this); } public EntitySize a(EntityPose entitypose) { return (entitypose == EntityPose.SLEEPING) ? ah : super.a(entitypose).a(cR()); } public ImmutableList<EntityPose> ei() { return ImmutableList.of(EntityPose.STANDING); } public AxisAlignedBB f(EntityPose entitypose) { EntitySize entitysize = a(entitypose); return new AxisAlignedBB((-entitysize.width / 2.0F), 0.0D, (-entitysize.width / 2.0F), (entitysize.width / 2.0F), entitysize.height, (entitysize.width / 2.0F)); } public Optional<BlockPosition> getBedPosition() { return this.datawatcher.<Optional<BlockPosition>>get(bj); } public void e(BlockPosition blockposition) { this.datawatcher.set(bj, Optional.of(blockposition)); } public void ek() { this.datawatcher.set(bj, Optional.empty()); } public boolean isSleeping() { return getBedPosition().isPresent(); } public void entitySleep(BlockPosition blockposition) { if (isPassenger()) stopRiding();  IBlockData iblockdata = this.world.getType(blockposition); if (iblockdata.getBlock() instanceof BlockBed) this.world.setTypeAndData(blockposition, iblockdata.set(BlockBed.OCCUPIED, Boolean.valueOf(true)), 3);  setPose(EntityPose.SLEEPING); a(blockposition); e(blockposition); setMot(Vec3D.ORIGIN); this.impulse = true; } private void a(BlockPosition blockposition) { setPosition(blockposition.getX() + 0.5D, blockposition.getY() + 0.6875D, blockposition.getZ() + 0.5D); } private boolean x() { return ((Boolean)getBedPosition().<Boolean>map(blockposition -> Boolean.valueOf(this.world.getType(blockposition).getBlock() instanceof BlockBed)).orElse(Boolean.valueOf(false))).booleanValue(); } public void entityWakeup() { Optional<BlockPosition> optional = getBedPosition(); World world = this.world; this.world.getClass(); Objects.requireNonNull(world); optional.filter(world::isLoaded).ifPresent(blockposition -> { IBlockData iblockdata = this.world.getType(blockposition); if (iblockdata.getBlock() instanceof BlockBed) { this.world.setTypeAndData(blockposition, iblockdata.set(BlockBed.OCCUPIED, Boolean.valueOf(false)), 3); Vec3D vec3d = BlockBed.a(getEntityType(), this.world, blockposition, this.yaw).orElseGet(()); Vec3D vec3d1 = Vec3D.c(blockposition).d(vec3d).d(); float f = (float)MathHelper.g(MathHelper.d(vec3d1.z, vec3d1.x) * 57.2957763671875D - 90.0D); setPosition(vec3d.x, vec3d.y, vec3d.z); this.yaw = f; this.pitch = 0.0F; }  }); Vec3D vec3d = getPositionVector(); setPose(EntityPose.STANDING); setPosition(vec3d.x, vec3d.y, vec3d.z); ek(); } public boolean inBlock() { return (!isSleeping() && super.inBlock()); } protected final float getHeadHeight(EntityPose entitypose, EntitySize entitysize) { return (entitypose == EntityPose.SLEEPING) ? 0.2F : b(entitypose, entitysize); } protected float b(EntityPose entitypose, EntitySize entitysize) { return super.getHeadHeight(entitypose, entitysize); } public ItemStack f(ItemStack itemstack) { return ItemStack.b; } public ItemStack a(World world, ItemStack itemstack) { if (itemstack.F()) { world.playSound((EntityHuman)null, locX(), locY(), locZ(), d(itemstack), SoundCategory.NEUTRAL, 1.0F, 1.0F + (world.random.nextFloat() - world.random.nextFloat()) * 0.4F); a(itemstack, world, this); if (!(this instanceof EntityHuman) || !((EntityHuman)this).abilities.canInstantlyBuild) itemstack.subtract(1);  }  return itemstack; } private void a(ItemStack itemstack, World world, EntityLiving entityliving) { Item item = itemstack.getItem(); if (item.isFood()) { List<Pair<MobEffect, Float>> list = item.getFoodInfo().f(); Iterator<Pair<MobEffect, Float>> iterator = list.iterator(); while (iterator.hasNext()) { Pair<MobEffect, Float> pair = iterator.next(); if (!world.isClientSide && pair.getFirst() != null && world.random.nextFloat() < ((Float)pair.getSecond()).floatValue()) entityliving.addEffect(new MobEffect((MobEffect)pair.getFirst()), EntityPotionEffectEvent.Cause.FOOD);  }  }  } private static byte f(EnumItemSlot enumitemslot) { switch (enumitemslot) { case MAINHAND: return 47;case OFFHAND: return 48;case HEAD: return 49;case CHEST: return 50;case FEET: return 52;case LEGS: return 51; }  return 47; } public void broadcastItemBreak(EnumItemSlot enumitemslot) { this.world.broadcastEntityEffect(this, f(enumitemslot)); } public void broadcastItemBreak(EnumHand enumhand) { broadcastItemBreak((enumhand == EnumHand.MAIN_HAND) ? EnumItemSlot.MAINHAND : EnumItemSlot.OFFHAND); } public MovingObjectPosition getRayTrace(int maxDistance) { return getRayTrace(maxDistance, RayTrace.FluidCollisionOption.NONE); } public MovingObjectPosition getRayTrace(int maxDistance, RayTrace.FluidCollisionOption fluidCollisionOption) { if (maxDistance < 1 || maxDistance > 120) throw new IllegalArgumentException("maxDistance must be between 1-120");  Vec3D start = new Vec3D(locX(), locY() + getHeadHeight(), locZ()); Vector dir = getBukkitEntity().getLocation().getDirection().multiply(maxDistance); Vec3D end = new Vec3D(start.x + dir.getX(), start.y + dir.getY(), start.z + dir.getZ()); RayTrace raytrace = new RayTrace(start, end, RayTrace.BlockCollisionOption.OUTLINE, fluidCollisionOption, this); return this.world.rayTrace(raytrace); } public MovingObjectPositionEntity getTargetEntity(int maxDistance) { if (maxDistance < 1 || maxDistance > 120) throw new IllegalArgumentException("maxDistance must be between 1-120");  Vec3D start = getEyePosition(1.0F); Vec3D direction = getLookDirection(); Vec3D end = start.add(direction.x * maxDistance, direction.y * maxDistance, direction.z * maxDistance); List<Entity> entityList = this.world.getEntities(this, getBoundingBox().expand(direction.x * maxDistance, direction.y * maxDistance, direction.z * maxDistance).grow(1.0D, 1.0D, 1.0D), IEntitySelector.canAITarget().and(Entity::isInteractable)); double distance = 0.0D; MovingObjectPositionEntity result = null; for (Entity entity : entityList) { AxisAlignedBB aabb = entity.getBoundingBox().grow(entity.getCollisionBorderSize()); Optional<Vec3D> rayTraceResult = aabb.calculateIntercept(start, end); if (rayTraceResult.isPresent()) { Vec3D rayTrace = rayTraceResult.get(); double distanceTo = start.distanceSquared(rayTrace); if (distanceTo < distance || distance == 0.0D) { result = new MovingObjectPositionEntity(entity, rayTrace); distance = distanceTo; }  }  }  return result; } public void setShieldBlockingDelay(int shieldBlockingDelay) { this.shieldBlockingDelay = shieldBlockingDelay; }
/*      */ 
/*      */   
/*      */   public abstract Iterable<ItemStack> getArmorItems();
/*      */   
/*      */   public abstract ItemStack getEquipment(EnumItemSlot paramEnumItemSlot);
/*      */   
/*      */   public abstract void setSlot(EnumItemSlot paramEnumItemSlot, ItemStack paramItemStack);
/*      */   
/*      */   public abstract EnumMainHand getMainHand();
/*      */ }


/* Location:              C:\Users\Josep\Downloads\Decompile Minecraft\tuinity-1.16.3.jar!\net\minecraft\server\v1_16_R2\EntityLiving.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */