/*      */ package net.minecraft.server.v1_16_R2;
/*      */ import com.google.common.base.Preconditions;
/*      */ import com.google.common.collect.Lists;
/*      */ import com.google.common.collect.Sets;
/*      */ import com.tuinity.tuinity.util.CachedLists;
/*      */ import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
/*      */ import java.lang.ref.WeakReference;
/*      */ import java.lang.reflect.Method;
/*      */ import java.util.Collection;
/*      */ import java.util.Collections;
/*      */ import java.util.Iterator;
/*      */ import java.util.List;
/*      */ import java.util.Locale;
/*      */ import java.util.Optional;
/*      */ import java.util.Random;
/*      */ import java.util.Set;
/*      */ import java.util.UUID;
/*      */ import java.util.concurrent.atomic.AtomicInteger;
/*      */ import java.util.stream.Stream;
/*      */ import javax.annotation.Nullable;
/*      */ import org.apache.logging.log4j.LogManager;
/*      */ import org.bukkit.Bukkit;
/*      */ import org.bukkit.Location;
/*      */ import org.bukkit.Server;
/*      */ import org.bukkit.World;
/*      */ import org.bukkit.block.Block;
/*      */ import org.bukkit.block.BlockFace;
/*      */ import org.bukkit.command.CommandSender;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.CraftWorld;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.entity.CraftEntity;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.entity.CraftPlayer;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.event.CraftEventFactory;
/*      */ import org.bukkit.craftbukkit.v1_16_R2.event.CraftPortalEvent;
/*      */ import org.bukkit.entity.Vehicle;
/*      */ import org.bukkit.event.Event;
/*      */ import org.bukkit.event.entity.CreatureSpawnEvent;
/*      */ import org.bukkit.event.entity.EntityAirChangeEvent;
/*      */ import org.bukkit.event.entity.EntityCombustByBlockEvent;
/*      */ import org.bukkit.event.entity.EntityCombustByEntityEvent;
/*      */ import org.bukkit.event.entity.EntityCombustEvent;
/*      */ import org.bukkit.event.entity.EntityDropItemEvent;
/*      */ import org.bukkit.event.entity.EntityPortalEvent;
/*      */ import org.bukkit.event.hanging.HangingBreakByEntityEvent;
/*      */ import org.bukkit.event.player.PlayerTeleportEvent;
/*      */ import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
/*      */ import org.bukkit.event.vehicle.VehicleEnterEvent;
/*      */ import org.bukkit.event.vehicle.VehicleExitEvent;
/*      */ import org.bukkit.plugin.PluginManager;
/*      */ import org.spigotmc.ActivationRange;
/*      */ import org.spigotmc.TrackingRange;
/*      */ import org.spigotmc.event.entity.EntityDismountEvent;
/*      */ import org.spigotmc.event.entity.EntityMountEvent;
/*      */ 
/*      */ public abstract class Entity implements INamableTileEntity, ICommandListener, KeyedObject {
/*      */   private static final int CURRENT_LEVEL = 2;
/*      */   boolean preserveMotion = true;
/*      */   
/*      */   static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
/*   59 */     return (tag.hasKey("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level);
/*      */   }
/*      */ 
/*      */   
/*      */   boolean isQueuedForRegister = false;
/*   64 */   public static Random SHARED_RANDOM = new Random() {
/*      */       private boolean locked = false;
/*      */       
/*      */       public synchronized void setSeed(long seed) {
/*   68 */         if (this.locked) {
/*   69 */           LogManager.getLogger().error("Ignoring setSeed on Entity.SHARED_RANDOM", new Throwable());
/*      */         } else {
/*   71 */           super.setSeed(seed);
/*   72 */           this.locked = true;
/*      */         } 
/*      */       }
/*      */     };
/*   76 */   List<Entity> entitySlice = null;
/*      */   
/*      */   public CreatureSpawnEvent.SpawnReason spawnReason;
/*      */   
/*      */   public PaperLootableInventoryData lootableData;
/*      */   private CraftEntity bukkitEntity;
/*      */   PlayerChunkMap.EntityTracker tracker;
/*      */   boolean collisionLoadChunks = false;
/*      */   Throwable addedToWorldStack;
/*      */   
/*      */   public CraftEntity getBukkitEntity() {
/*   87 */     if (this.bukkitEntity == null) {
/*   88 */       this.bukkitEntity = CraftEntity.getEntity(this.world.getServer(), this);
/*      */     }
/*   90 */     return this.bukkitEntity;
/*      */   }
/*      */ 
/*      */   
/*      */   public CommandSender getBukkitSender(CommandListenerWrapper wrapper) {
/*   95 */     return (CommandSender)getBukkitEntity();
/*      */   }
/*      */ 
/*      */   
/*   99 */   protected static final Logger LOGGER = LogManager.getLogger();
/*  100 */   private static final AtomicInteger entityCount = new AtomicInteger();
/*  101 */   private static final List<ItemStack> c = Collections.emptyList();
/*  102 */   private static final AxisAlignedBB d = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
/*  103 */   private static double e = 1.0D; private final EntityTypes<?> f; private int id; public boolean i; public final List<Entity> passengers; protected int j; @Nullable
/*      */   private Entity vehicle; public boolean attachedToPlayer; public World world; public double lastX; public double lastY; public double lastZ; private Vec3D loc; private BlockPosition locBlock; private Vec3D mot; public float yaw; public float pitch; public float lastYaw; public float lastPitch; private AxisAlignedBB boundingBox; protected boolean onGround; public boolean positionChanged; public boolean v; public boolean velocityChanged; protected Vec3D x; public boolean dead; public float z; public float A; public float B; public float fallDistance; private float am; private float an; public double D; public double E; public double F; public float G; public boolean noclip; public float I; protected final Random random; public int ticksLived; public int fireTicks; public boolean inWater; protected Object2DoubleMap<Tag<FluidType>> M; protected boolean N; @Nullable
/*      */   protected Tag<FluidType> O; public int noDamageTicks; protected boolean justCreated; protected final DataWatcher datawatcher; public final boolean blocksEntitySpawning() {
/*  106 */     return this.i;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*      */   public final float getStepHeight() {
/*  139 */     return this.G;
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  153 */   protected static final DataWatcherObject<Byte> S = DataWatcher.a(Entity.class, DataWatcherRegistry.a);
/*  154 */   private static final DataWatcherObject<Integer> AIR_TICKS = DataWatcher.a(Entity.class, DataWatcherRegistry.b);
/*  155 */   private static final DataWatcherObject<Optional<IChatBaseComponent>> aq = DataWatcher.a(Entity.class, DataWatcherRegistry.f);
/*  156 */   private static final DataWatcherObject<Boolean> ar = DataWatcher.a(Entity.class, DataWatcherRegistry.i);
/*  157 */   private static final DataWatcherObject<Boolean> as = DataWatcher.a(Entity.class, DataWatcherRegistry.i);
/*  158 */   private static final DataWatcherObject<Boolean> at = DataWatcher.a(Entity.class, DataWatcherRegistry.i);
/*  159 */   protected static final DataWatcherObject<EntityPose> POSE = DataWatcher.a(Entity.class, DataWatcherRegistry.s);
/*      */   
/*      */   public boolean inChunk;
/*      */   
/*      */   public int chunkX;
/*      */   public int chunkY;
/*      */   public int chunkZ;
/*      */   private boolean au;
/*      */   private Vec3D av;
/*      */   public boolean Y;
/*      */   public boolean impulse;
/*      */   public int portalCooldown;
/*      */   public boolean inPortal;
/*      */   protected int portalTicks;
/*      */   protected BlockPosition ac;
/*      */   private boolean invulnerable;
/*      */   protected UUID uniqueID;
/*      */   protected String ae;
/*      */   public boolean glowing;
/*      */   private final Set<String> ay;
/*      */   private boolean az;
/*      */   private final double[] aA;
/*      */   private long aB;
/*      */   private EntitySize size;
/*      */   private float headHeight;
/*      */   public boolean persist = true;
/*      */   public boolean valid;
/*      */   public ProjectileSource projectileSource;
/*      */   public boolean forceExplosionKnockback;
/*      */   public boolean persistentInvisibility = false;
/*      */   public Location origin;
/*  190 */   public final ActivationRange.ActivationType activationType = ActivationRange.initializeEntityActivationType(this);
/*      */   public final boolean defaultActivationState;
/*  192 */   public long activatedTick = -2147483648L;
/*      */   public boolean isTemporarilyActive = false;
/*      */   public boolean spawnedViaMobSpawner;
/*      */   public boolean fromNetherPortal;
/*  196 */   protected int numCollisions = 0;
/*      */   public boolean shouldBeRemoved;
/*      */   
/*      */   public void inactiveTick() {}
/*      */   
/*      */   public float getBukkitYaw() {
/*  202 */     return this.yaw;
/*      */   }
/*      */   
/*      */   public boolean isChunkLoaded() {
/*  206 */     return (getCurrentChunk() != null);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public final AxisAlignedBB getBoundingBoxAt(double x, double y, double z) {
/*  212 */     double widthHalf = this.size.width / 2.0D;
/*  213 */     double height = this.size.height;
/*  214 */     return new AxisAlignedBB(x - widthHalf, y, z - widthHalf, x + widthHalf, y + height, z + widthHalf);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*  219 */   final TrackingRange.TrackingRangeType trackingRangeType = TrackingRange.getTrackingRangeType(this);
/*      */   boolean isLegacyTrackingEntity = false;
/*      */   private final boolean hardCollides;
/*      */   
/*      */   public final void setLegacyTrackingEntity(boolean isLegacyTrackingEntity) {
/*  224 */     this.isLegacyTrackingEntity = isLegacyTrackingEntity;
/*      */   }
/*      */   
/*      */   final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> getPlayersInTrackRange() {
/*  228 */     return (((WorldServer)this.world).getChunkProvider()).playerChunkMap.playerEntityTrackerTrackMaps[this.trackingRangeType.ordinal()]
/*  229 */       .getObjectsInRange(MCUtil.getCoordinateKey(this));
/*      */   }
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */   
/*  239 */   private static final Map<Class<? extends Entity>, Boolean> cachedOverrides = Collections.synchronizedMap(new WeakHashMap<>()); private Vec3D moveVector; private double moveStartX; private double moveStartY; private double moveStartZ; WeakReference<Chunk> currentChunk; private MinecraftKey entityKey; private String entityKeyString; public final Object posLock;
/*      */   
/*  241 */   public Entity(EntityTypes<?> entitytypes, World world) { Boolean hardCollides = cachedOverrides.get(getClass());
/*  242 */     if (hardCollides == null) {
/*      */       try {
/*  244 */         Method getHardCollisionBoxEntityMethod = Entity.class.getMethod("j", new Class[] { Entity.class });
/*  245 */         Method hasHardCollisionBoxMethod = Entity.class.getMethod("aY", new Class[0]);
/*  246 */         if (!getClass().getMethod(hasHardCollisionBoxMethod.getName(), hasHardCollisionBoxMethod.getParameterTypes()).equals(hasHardCollisionBoxMethod) || 
/*  247 */           !getClass().getMethod(getHardCollisionBoxEntityMethod.getName(), getHardCollisionBoxEntityMethod.getParameterTypes()).equals(getHardCollisionBoxEntityMethod)) {
/*  248 */           hardCollides = Boolean.TRUE;
/*      */         } else {
/*  250 */           hardCollides = Boolean.FALSE;
/*      */         } 
/*  252 */         cachedOverrides.put(getClass(), hardCollides);
/*      */       } catch (ThreadDeath thr) {
/*  254 */         throw thr;
/*  255 */       } catch (Throwable thr) {
/*      */         
/*  257 */         throw new RuntimeException(thr);
/*      */       } 
/*      */     }
/*  260 */     this.hardCollides = hardCollides.booleanValue();
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 2016 */     this.currentChunk = null;
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */ 
/*      */     
/* 3507 */     this.posLock = new Object(); this.id = entityCount.incrementAndGet(); this.passengers = Lists.newArrayList(); this.mot = Vec3D.ORIGIN; this.boundingBox = d; this.x = Vec3D.ORIGIN; this.am = 1.0F; this.an = 1.0F; this.random = SHARED_RANDOM; this.fireTicks = -getMaxFireTicks(); this.M = (Object2DoubleMap<Tag<FluidType>>)new Object2DoubleArrayMap(2); this.justCreated = true; this.uniqueID = MathHelper.a(this.random); this.ae = this.uniqueID.toString(); this.ay = Sets.newHashSet(); this.aA = new double[] { 0.0D, 0.0D, 0.0D }; this.f = entitytypes; this.world = world; this.size = entitytypes.l(); this.loc = Vec3D.ORIGIN; this.locBlock = BlockPosition.ZERO; this.av = Vec3D.ORIGIN; setPosition(0.0D, 0.0D, 0.0D); if (world != null) { this.defaultActivationState = ActivationRange.initializeEntityActivationState(this, world.spigotConfig); } else { this.defaultActivationState = false; }  this.datawatcher = new DataWatcher(this); this.datawatcher.register(S, Byte.valueOf((byte)0)); this.datawatcher.register(AIR_TICKS, Integer.valueOf(bG())); this.datawatcher.register(ar, Boolean.valueOf(false)); this.datawatcher.register(aq, Optional.empty()); this.datawatcher.register(as, Boolean.valueOf(false)); this.datawatcher.register(at, Boolean.valueOf(false)); this.datawatcher.register(POSE, EntityPose.STANDING); initDatawatcher(); this.datawatcher.registrationLocked = true; this.headHeight = getHeadHeight(EntityPose.STANDING, this.size); }
/*      */   public final boolean hardCollides() { return this.hardCollides; }
/*      */   public boolean isSpectator() { return false; }
/* 3510 */   public final void decouple() { if (isVehicle()) ejectPassengers();  if (isPassenger()) stopRiding();  } public void c(double d0, double d1, double d2) { a(new Vec3D(d0, d1, d2)); } public void a(Vec3D vec3d) { this.av = vec3d; } public EntityTypes<?> getEntityType() { return this.f; } public int getId() { return this.id; } public void e(int i) { this.id = i; } public Set<String> getScoreboardTags() { return this.ay; } public boolean addScoreboardTag(String s) { return (this.ay.size() >= 1024) ? false : this.ay.add(s); } public boolean removeScoreboardTag(String s) { return this.ay.remove(s); } public void killEntity() { die(); } public DataWatcher getDataWatcher() { return this.datawatcher; } public boolean equals(Object object) { return (object instanceof Entity) ? ((((Entity)object).id == this.id)) : false; } public int hashCode() { return this.id; } public void die() { this.dead = true; } public void setPose(EntityPose entitypose) { if (entitypose == getPose()) return;  this.world.getServer().getPluginManager().callEvent((Event)new EntityPoseChangeEvent((org.bukkit.entity.Entity)getBukkitEntity(), Pose.values()[entitypose.ordinal()])); this.datawatcher.set(POSE, entitypose); } public EntityPose getPose() { return this.datawatcher.<EntityPose>get(POSE); } public boolean a(Entity entity, double d0) { double d1 = entity.loc.x - this.loc.x; double d2 = entity.loc.y - this.loc.y; double d3 = entity.loc.z - this.loc.z; return (d1 * d1 + d2 * d2 + d3 * d3 < d0 * d0); } protected void setYawPitch(float f, float f1) { if (Float.isNaN(f)) f = 0.0F;  if (f == Float.POSITIVE_INFINITY || f == Float.NEGATIVE_INFINITY) { if (this instanceof EntityPlayer) { this.world.getServer().getLogger().warning(getName() + " was caught trying to crash the server with an invalid yaw"); ((CraftPlayer)getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)"); }  f = 0.0F; }  if (Float.isNaN(f1)) f1 = 0.0F;  if (f1 == Float.POSITIVE_INFINITY || f1 == Float.NEGATIVE_INFINITY) { if (this instanceof EntityPlayer) { this.world.getServer().getLogger().warning(getName() + " was caught trying to crash the server with an invalid pitch"); ((CraftPlayer)getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)"); }  f1 = 0.0F; }  this.yaw = f % 360.0F; this.pitch = f1 % 360.0F; } public void setPosition(double d0, double d1, double d2) { setPositionRaw(d0, d1, d2); if (this.valid) ((WorldServer)this.world).chunkCheck(this);  } protected void ae() { setPosition(this.loc.x, this.loc.y, this.loc.z); } public void tick() { if (!this.world.isClientSide) setFlag(6, bD());  entityBaseTick(); } public void postTick() { if (!(this instanceof EntityPlayer)) doPortalTick();  } public void entityBaseTick() { this.world.getMethodProfiler().enter("entityBaseTick"); if (isPassenger() && (getVehicle()).dead) stopRiding();  if (this.j > 0) this.j--;  this.z = this.A; this.lastPitch = this.pitch; this.lastYaw = this.yaw; if (this instanceof EntityPlayer) doPortalTick();  if (aN()) aO();  aJ(); m(); aI(); if (this.world.isClientSide) { extinguish(); } else if (this.fireTicks > 0) { if (isFireProof()) { setFireTicks(this.fireTicks - 4); if (this.fireTicks < 0) extinguish();  } else { if (this.fireTicks % 20 == 0 && !aP()) damageEntity(DamageSource.BURN, 1.0F);  setFireTicks(this.fireTicks - 1); }  }  if (aP()) { burnFromLava(); this.fallDistance *= 0.5F; }  performVoidDamage(); if (!this.world.isClientSide) setFlag(0, (this.fireTicks > 0));  this.justCreated = false; this.world.getMethodProfiler().exit(); } public void resetPortalCooldown() { this.portalCooldown = getDefaultPortalCooldown(); } public boolean ah() { return (this.portalCooldown > 0); } protected void E() { if (ah()) this.portalCooldown--;  } public int ai() { return 0; } protected void burnFromLava() { if (!isFireProof()) { if (this instanceof EntityLiving && this.fireTicks <= 0) { Block damager = null; CraftEntity craftEntity = getBukkitEntity(); EntityCombustByBlockEvent entityCombustByBlockEvent = new EntityCombustByBlockEvent(damager, (org.bukkit.entity.Entity)craftEntity, 15); this.world.getServer().getPluginManager().callEvent((Event)entityCombustByBlockEvent); if (!entityCombustByBlockEvent.isCancelled()) setOnFire(entityCombustByBlockEvent.getDuration(), false);  } else { setOnFire(15, false); }  damageEntity(DamageSource.LAVA, 4.0F); }  } public void setOnFire(int i) { setOnFire(i, true); } public void setOnFire(int i, boolean callEvent) { if (callEvent) { EntityCombustEvent event = new EntityCombustEvent((org.bukkit.entity.Entity)getBukkitEntity(), i); this.world.getServer().getPluginManager().callEvent((Event)event); if (event.isCancelled()) return;  i = event.getDuration(); }  int j = i * 20; if (this instanceof EntityLiving) j = EnchantmentProtection.a((EntityLiving)this, j);  if (this.fireTicks < j) setFireTicks(j);  } public void setFireTicks(int i) { this.fireTicks = i; } public int getFireTicks() { return this.fireTicks; } public void extinguish() { setFireTicks(0); } protected void performVoidDamage() { if (locY() < -64.0D || (this.world.getWorld().getEnvironment() == World.Environment.NETHER && this.world.paperConfig.doNetherTopVoidDamage() && locY() >= this.world.paperConfig.netherVoidTopDamageHeight)) doVoidDamage();  } protected final void doVoidDamage() { am(); } protected void am() { die(); } public boolean e(double d0, double d1, double d2) { return b(getBoundingBox().d(d0, d1, d2)); } private boolean b(AxisAlignedBB axisalignedbb) { return (this.world.getCubes(this, axisalignedbb) && !this.world.containsLiquid(axisalignedbb)); } public void setOnGround(boolean flag) { this.onGround = flag; } public boolean isOnGround() { return this.onGround; } public final Vec3D getMoveVector() { return this.moveVector; } public final double getMoveStartX() { return this.moveStartX; } public final double getMoveStartY() { return this.moveStartY; } public final double getMoveStartZ() { return this.moveStartZ; } public void move(EnumMoveType enummovetype, Vec3D vec3d) { TickThread.ensureTickThread("Cannot move an entity off-main"); synchronized (this.posLock) { this.moveStartX = locX(); this.moveStartY = locY(); this.moveStartZ = locZ(); this.moveVector = vec3d; }  try { if (this.noclip) { a(getBoundingBox().c(vec3d)); recalcPosition(); } else { if (enummovetype == EnumMoveType.PISTON) { this.activatedTick = (MinecraftServer.currentTick + 20); vec3d = b(vec3d); if (vec3d.equals(Vec3D.ORIGIN)) return;  }  this.world.getMethodProfiler().enter("move"); if (this.x.g() > 1.0E-7D) { vec3d = vec3d.h(this.x); this.x = Vec3D.ORIGIN; setMot(Vec3D.ORIGIN); }  if (this.isTemporarilyActive && !(this instanceof EntityItem) && !(this instanceof EntityMinecartAbstract) && vec3d == getMot() && enummovetype == EnumMoveType.SELF) { setMot(Vec3D.ORIGIN); this.world.getMethodProfiler().exit(); return; }  vec3d = a(vec3d, enummovetype); Vec3D vec3d1 = performCollision(vec3d); if (vec3d1.g() > 1.0E-7D) { a(getBoundingBox().c(vec3d1)); recalcPosition(); }  this.world.getMethodProfiler().exit(); this.world.getMethodProfiler().enter("rest"); this.positionChanged = (!MathHelper.b(vec3d.x, vec3d1.x) || !MathHelper.b(vec3d.z, vec3d1.z)); this.v = (vec3d.y != vec3d1.y); this.onGround = (this.v && vec3d.y < 0.0D); BlockPosition blockposition = ao(); IBlockData iblockdata = this.world.getType(blockposition); a(vec3d1.y, this.onGround, iblockdata, blockposition); Vec3D vec3d2 = getMot(); if (vec3d.x != vec3d1.x) setMot(0.0D, vec3d2.y, vec3d2.z);  if (vec3d.z != vec3d1.z) setMot(vec3d2.x, vec3d2.y, 0.0D);  Block block = iblockdata.getBlock(); if (vec3d.y != vec3d1.y) block.a(this.world, this);  if (this.positionChanged && getBukkitEntity() instanceof Vehicle) { Vehicle vehicle = (Vehicle)getBukkitEntity(); Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(locX()), MathHelper.floor(locY()), MathHelper.floor(locZ())); if (vec3d.x > vec3d1.x) { bl = bl.getRelative(BlockFace.EAST); } else if (vec3d.x < vec3d1.x) { bl = bl.getRelative(BlockFace.WEST); } else if (vec3d.z > vec3d1.z) { bl = bl.getRelative(BlockFace.SOUTH); } else if (vec3d.z < vec3d1.z) { bl = bl.getRelative(BlockFace.NORTH); }  if (!bl.getType().isAir()) { VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl); this.world.getServer().getPluginManager().callEvent((Event)event); }  }  if (this.onGround && !bu()) block.stepOn(this.world, blockposition, this);  if (playStepSound() && !isPassenger()) { double d0 = vec3d1.x; double d1 = vec3d1.y; double d2 = vec3d1.z; if (!block.a(TagsBlock.CLIMBABLE)) d1 = 0.0D;  this.A = (float)(this.A + MathHelper.sqrt(c(vec3d1)) * 0.6D); this.B = (float)(this.B + MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 0.6D); if (this.B > this.am && !iblockdata.isAir()) { this.am = as(); if (isInWater()) { Entity entity = (isVehicle() && getRidingPassenger() != null) ? getRidingPassenger() : this; float f = (entity == this) ? 0.35F : 0.4F; Vec3D vec3d3 = entity.getMot(); float f1 = MathHelper.sqrt(vec3d3.x * vec3d3.x * 0.20000000298023224D + vec3d3.y * vec3d3.y + vec3d3.z * vec3d3.z * 0.20000000298023224D) * f; if (f1 > 1.0F) f1 = 1.0F;  d(f1); } else { b(blockposition, iblockdata); }  } else if (this.B > this.an && ay() && iblockdata.isAir()) { this.an = e(this.B); }  }  try { checkBlockCollisions(); } catch (Throwable throwable) { CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision"); CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision"); appendEntityCrashDetails(crashreportsystemdetails); throw new ReportedException(crashreport); }  float f2 = getBlockSpeedFactor(); setMot(getMot().d(f2, 1.0D, f2)); if (this.world.c(getBoundingBox().shrink(0.001D)).noneMatch(iblockdata1 -> (iblockdata1.a(TagsBlock.FIRE) || iblockdata1.a(Blocks.LAVA))) && this.fireTicks <= 0) setFireTicks(-getMaxFireTicks());  if (aF() && isBurning()) { playSound(SoundEffects.ENTITY_GENERIC_EXTINGUISH_FIRE, 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F); setFireTicks(-getMaxFireTicks()); }  this.world.getMethodProfiler().exit(); }  } finally { synchronized (this.posLock) { this.moveVector = null; }  }  } protected BlockPosition ao() { int i = MathHelper.floor(this.loc.x); int j = MathHelper.floor(this.loc.y - 0.20000000298023224D); int k = MathHelper.floor(this.loc.z); BlockPosition blockposition = new BlockPosition(i, j, k); if (this.world.getType(blockposition).isAir()) { BlockPosition blockposition1 = blockposition.down(); IBlockData iblockdata = this.world.getType(blockposition1); Block block = iblockdata.getBlock(); if (block.a(TagsBlock.FENCES) || block.a(TagsBlock.WALLS) || block instanceof BlockFenceGate) return blockposition1;  }  return blockposition; } protected float getBlockJumpFactor() { float f = this.world.getType(getChunkCoordinates()).getBlock().getJumpFactor(); float f1 = this.world.getType(ar()).getBlock().getJumpFactor(); return (f == 1.0D) ? f1 : f; } protected float getBlockSpeedFactor() { Block block = this.world.getType(getChunkCoordinates()).getBlock(); float f = block.getSpeedFactor(); return (block != Blocks.WATER && block != Blocks.BUBBLE_COLUMN) ? ((f == 1.0D) ? this.world.getType(ar()).getBlock().getSpeedFactor() : f) : f; } protected BlockPosition ar() { return new BlockPosition(this.loc.x, (getBoundingBox()).minY - 0.5000001D, this.loc.z); } protected Vec3D a(Vec3D vec3d, EnumMoveType enummovetype) { return vec3d; } protected Vec3D b(Vec3D vec3d) { if (vec3d.g() <= 1.0E-7D) return vec3d;  long i = this.world.getTime(); if (i != this.aB) { Arrays.fill(this.aA, 0.0D); this.aB = i; }  if (vec3d.x != 0.0D) { double d0 = a(EnumDirection.EnumAxis.X, vec3d.x); return (Math.abs(d0) <= 9.999999747378752E-6D) ? Vec3D.ORIGIN : new Vec3D(d0, 0.0D, 0.0D); }  if (vec3d.y != 0.0D) { double d0 = a(EnumDirection.EnumAxis.Y, vec3d.y); return (Math.abs(d0) <= 9.999999747378752E-6D) ? Vec3D.ORIGIN : new Vec3D(0.0D, d0, 0.0D); }  if (vec3d.z != 0.0D) { double d0 = a(EnumDirection.EnumAxis.Z, vec3d.z); return (Math.abs(d0) <= 9.999999747378752E-6D) ? Vec3D.ORIGIN : new Vec3D(0.0D, 0.0D, d0); }  return Vec3D.ORIGIN; } private double a(EnumDirection.EnumAxis enumdirection_enumaxis, double d0) { int i = enumdirection_enumaxis.ordinal(); double d1 = MathHelper.a(d0 + this.aA[i], -0.51D, 0.51D); d0 = d1 - this.aA[i]; this.aA[i] = d1; return d0; } private static double performCollisionsX(AxisAlignedBB currentBoundingBox, double value, List<AxisAlignedBB> potentialCollisions) { for (int i = 0, len = potentialCollisions.size(); i < len; i++) { if (Math.abs(value) < 1.0E-7D) return 0.0D;  AxisAlignedBB target = potentialCollisions.get(i); value = AxisAlignedBB.collideX(target, currentBoundingBox, value); }  return value; } private static double performCollisionsY(AxisAlignedBB currentBoundingBox, double value, List<AxisAlignedBB> potentialCollisions) { for (int i = 0, len = potentialCollisions.size(); i < len; i++) { if (Math.abs(value) < 1.0E-7D) return 0.0D;  AxisAlignedBB target = potentialCollisions.get(i); value = AxisAlignedBB.collideY(target, currentBoundingBox, value); }  return value; } private static double performCollisionsZ(AxisAlignedBB currentBoundingBox, double value, List<AxisAlignedBB> potentialCollisions) { for (int i = 0, len = potentialCollisions.size(); i < len; i++) { if (Math.abs(value) < 1.0E-7D) return 0.0D;  AxisAlignedBB target = potentialCollisions.get(i); value = AxisAlignedBB.collideZ(target, currentBoundingBox, value); }  return value; } private static Vec3D performCollisions(Vec3D moveVector, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> potentialCollisions) { double x = moveVector.x; double y = moveVector.y; double z = moveVector.z; if (y != 0.0D) { y = performCollisionsY(axisalignedbb, y, potentialCollisions); if (y != 0.0D) axisalignedbb = axisalignedbb.offsetY(y);  }  boolean xSmaller = (Math.abs(x) < Math.abs(z)); if (xSmaller && z != 0.0D) { z = performCollisionsZ(axisalignedbb, z, potentialCollisions); if (z != 0.0D) axisalignedbb = axisalignedbb.offsetZ(z);  }  if (x != 0.0D) { x = performCollisionsX(axisalignedbb, x, potentialCollisions); if (!xSmaller && x != 0.0D) axisalignedbb = axisalignedbb.offsetX(x);  }  if (!xSmaller && z != 0.0D) z = performCollisionsZ(axisalignedbb, z, potentialCollisions);  return new Vec3D(x, y, z); } Vec3D performCollision(Vec3D moveVector) { if (moveVector.getX() == 0.0D && moveVector.getY() == 0.0D && moveVector.getZ() == 0.0D) return moveVector;  WorldServer world = (WorldServer)this.world; AxisAlignedBB currBoundingBox = getBoundingBox(); List<AxisAlignedBB> potentialCollisions = CachedLists.getTempCollisionList(); try { AxisAlignedBB collisionBox; double stepHeight = getStepHeight(); if (stepHeight > 0.0D && (this.onGround || moveVector.y < 0.0D) && (moveVector.x != 0.0D || moveVector.z != 0.0D)) { if (moveVector.y <= 0.0D) { collisionBox = currBoundingBox.expand(moveVector.x, moveVector.y, moveVector.z).expandUpwards(stepHeight); } else { collisionBox = currBoundingBox.expand(moveVector.x, Math.max(stepHeight, moveVector.y), moveVector.z); }  } else { collisionBox = currBoundingBox.expand(moveVector.x, moveVector.y, moveVector.z); }  world.getCollisions(this, collisionBox, potentialCollisions, (this instanceof EntityPlayer && !this.world.paperConfig.preventMovingIntoUnloadedChunks)); Vec3D limitedMoveVector = performCollisions(moveVector, currBoundingBox, potentialCollisions); if (stepHeight > 0.0D && (this.onGround || (limitedMoveVector.y != moveVector.y && moveVector.y < 0.0D)) && (limitedMoveVector.x != moveVector.x || limitedMoveVector.z != moveVector.z)) { Vec3D vec3d2 = performCollisions(new Vec3D(moveVector.x, stepHeight, moveVector.z), currBoundingBox, potentialCollisions); Vec3D vec3d3 = performCollisions(new Vec3D(0.0D, stepHeight, 0.0D), currBoundingBox.expand(moveVector.x, 0.0D, moveVector.z), potentialCollisions); if (vec3d3.y < stepHeight) { Vec3D vec3d4 = performCollisions(new Vec3D(moveVector.x, 0.0D, moveVector.z), currBoundingBox.offset(vec3d3), potentialCollisions); if (getXZSquared(vec3d4) > getXZSquared(vec3d2)) vec3d2 = vec3d4;  }  if (getXZSquared(vec3d2) > getXZSquared(limitedMoveVector)) return vec3d2.add(performCollisions(new Vec3D(0.0D, -vec3d2.y + moveVector.y, 0.0D), currBoundingBox.offset(vec3d2), potentialCollisions));  return limitedMoveVector; }  return limitedMoveVector; } finally { CachedLists.returnTempCollisionList(potentialCollisions); }  } private Vec3D g(Vec3D vec3d) { AxisAlignedBB axisalignedbb = getBoundingBox(); VoxelShapeCollision voxelshapecollision = VoxelShapeCollision.a(this); VoxelShape voxelshape = this.world.getWorldBorder().c(); Stream<VoxelShape> stream = !this.world.getWorldBorder().isInBounds(axisalignedbb) ? Stream.<VoxelShape>empty() : Stream.<VoxelShape>of(voxelshape); Stream<VoxelShape> stream1 = this.world.c(this, axisalignedbb.b(vec3d), entity -> true); StreamAccumulator<VoxelShape> streamaccumulator = new StreamAccumulator<>(Stream.concat(stream1, stream)); Vec3D vec3d1 = (vec3d.g() == 0.0D) ? vec3d : a(this, vec3d, axisalignedbb, this.world, voxelshapecollision, streamaccumulator); boolean flag = (vec3d.x != vec3d1.x); boolean flag1 = (vec3d.y != vec3d1.y); boolean flag2 = (vec3d.z != vec3d1.z); boolean flag3 = (this.onGround || (flag1 && vec3d.y < 0.0D)); if (this.G > 0.0F && flag3 && (flag || flag2)) { Vec3D vec3d2 = a(this, new Vec3D(vec3d.x, this.G, vec3d.z), axisalignedbb, this.world, voxelshapecollision, streamaccumulator); Vec3D vec3d3 = a(this, new Vec3D(0.0D, this.G, 0.0D), axisalignedbb.b(vec3d.x, 0.0D, vec3d.z), this.world, voxelshapecollision, streamaccumulator); if (vec3d3.y < this.G) { Vec3D vec3d4 = a(this, new Vec3D(vec3d.x, 0.0D, vec3d.z), axisalignedbb.c(vec3d3), this.world, voxelshapecollision, streamaccumulator).e(vec3d3); if (c(vec3d4) > c(vec3d2)) vec3d2 = vec3d4;  }  if (c(vec3d2) > c(vec3d1)) return vec3d2.e(a(this, new Vec3D(0.0D, -vec3d2.y + vec3d.y, 0.0D), axisalignedbb.c(vec3d2), this.world, voxelshapecollision, streamaccumulator));  }  return vec3d1; } public static double getXZSquared(Vec3D vec3d) { return c(vec3d); } public static double c(Vec3D vec3d) { return vec3d.x * vec3d.x + vec3d.z * vec3d.z; } public static Vec3D a(@Nullable Entity entity, Vec3D vec3d, AxisAlignedBB axisalignedbb, World world, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) { boolean flag = (vec3d.x == 0.0D); boolean flag1 = (vec3d.y == 0.0D); boolean flag2 = (vec3d.z == 0.0D); if ((!flag || !flag1) && (!flag || !flag2) && (!flag1 || !flag2)) { StreamAccumulator<VoxelShape> streamaccumulator1 = new StreamAccumulator<>(Stream.concat(streamaccumulator.a(), world.b(entity, axisalignedbb.b(vec3d)))); return a(vec3d, axisalignedbb, streamaccumulator1); }  return a(vec3d, axisalignedbb, world, voxelshapecollision, streamaccumulator); } public static Vec3D a(Vec3D vec3d, AxisAlignedBB axisalignedbb, StreamAccumulator<VoxelShape> streamaccumulator) { double d0 = vec3d.x; double d1 = vec3d.y; double d2 = vec3d.z; if (d1 != 0.0D) { d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, streamaccumulator.a(), d1); if (d1 != 0.0D) axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);  }  boolean flag = (Math.abs(d0) < Math.abs(d2)); if (flag && d2 != 0.0D) { d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, streamaccumulator.a(), d2); if (d2 != 0.0D) axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);  }  if (d0 != 0.0D) { d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, streamaccumulator.a(), d0); if (!flag && d0 != 0.0D) axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);  }  if (!flag && d2 != 0.0D) d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, streamaccumulator.a(), d2);  return new Vec3D(d0, d1, d2); } public static Vec3D a(Vec3D vec3d, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) { double d0 = vec3d.x; double d1 = vec3d.y; double d2 = vec3d.z; if (d1 != 0.0D) { d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, iworldreader, d1, voxelshapecollision, streamaccumulator.a()); if (d1 != 0.0D) axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);  }  boolean flag = (Math.abs(d0) < Math.abs(d2)); if (flag && d2 != 0.0D) { d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, streamaccumulator.a()); if (d2 != 0.0D) axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);  }  if (d0 != 0.0D) { d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, iworldreader, d0, voxelshapecollision, streamaccumulator.a()); if (!flag && d0 != 0.0D) axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);  }  if (!flag && d2 != 0.0D) d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, streamaccumulator.a());  return new Vec3D(d0, d1, d2); } protected float as() { return ((int)this.B + 1); } public void recalcPosition() { AxisAlignedBB axisalignedbb = getBoundingBox(); setPositionRaw((axisalignedbb.minX + axisalignedbb.maxX) / 2.0D, axisalignedbb.minY, (axisalignedbb.minZ + axisalignedbb.maxZ) / 2.0D); if (this.valid) ((WorldServer)this.world).chunkCheck(this);  } protected SoundEffect getSoundSwim() { return SoundEffects.ENTITY_GENERIC_SWIM; } protected SoundEffect getSoundSplash() { return SoundEffects.ENTITY_GENERIC_SPLASH; } protected SoundEffect getSoundSplashHighSpeed() { return SoundEffects.ENTITY_GENERIC_SPLASH; } protected void checkBlockCollisions() { AxisAlignedBB axisalignedbb = getBoundingBox(); BlockPosition blockposition = new BlockPosition(axisalignedbb.minX + 0.001D, axisalignedbb.minY + 0.001D, axisalignedbb.minZ + 0.001D); BlockPosition blockposition1 = new BlockPosition(axisalignedbb.maxX - 0.001D, axisalignedbb.maxY - 0.001D, axisalignedbb.maxZ - 0.001D); BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(); if (this.world.areChunksLoadedBetween(blockposition, blockposition1)) for (int i = blockposition.getX(); i <= blockposition1.getX(); i++) { for (int j = blockposition.getY(); j <= blockposition1.getY(); j++) { for (int k = blockposition.getZ(); k <= blockposition1.getZ(); k++) { blockposition_mutableblockposition.d(i, j, k); IBlockData iblockdata = this.world.getType(blockposition_mutableblockposition); try { iblockdata.a(this.world, blockposition_mutableblockposition, this); a(iblockdata); } catch (Throwable throwable) { CrashReport crashreport = CrashReport.a(throwable, "Colliding entity with block"); CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being collided with"); CrashReportSystemDetails.a(crashreportsystemdetails, blockposition_mutableblockposition, iblockdata); throw new ReportedException(crashreport); }  }  }  }   } protected void a(IBlockData iblockdata) {} protected void b(BlockPosition blockposition, IBlockData iblockdata) { if (!iblockdata.getMaterial().isLiquid()) { IBlockData iblockdata1 = this.world.getType(blockposition.up()); SoundEffectType soundeffecttype = iblockdata1.a(Blocks.SNOW) ? iblockdata1.getStepSound() : iblockdata.getStepSound(); playSound(soundeffecttype.d(), soundeffecttype.a() * 0.15F, soundeffecttype.b()); }  } protected void d(float f) { playSound(getSoundSwim(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F); } protected float e(float f) { return 0.0F; } protected boolean ay() { return false; } public void playSound(SoundEffect soundeffect, float f, float f1) { if (!isSilent()) this.world.playSound((EntityHuman)null, locX(), locY(), locZ(), soundeffect, getSoundCategory(), f, f1);  } public boolean isSilent() { return ((Boolean)this.datawatcher.<Boolean>get(as)).booleanValue(); } public void setSilent(boolean flag) { this.datawatcher.set(as, Boolean.valueOf(flag)); } public boolean isNoGravity() { return ((Boolean)this.datawatcher.<Boolean>get(at)).booleanValue(); } public void setNoGravity(boolean flag) { this.datawatcher.set(at, Boolean.valueOf(flag)); } protected boolean playStepSound() { return true; } protected void a(double d0, boolean flag, IBlockData iblockdata, BlockPosition blockposition) { if (flag) { if (this.fallDistance > 0.0F) iblockdata.getBlock().fallOn(this.world, blockposition, this, this.fallDistance);  this.fallDistance = 0.0F; } else if (d0 < 0.0D) { this.fallDistance = (float)(this.fallDistance - d0); }  } public boolean isFireProof() { return getEntityType().c(); } public boolean b(float f, float f1) { if (isVehicle()) { Iterator<Entity> iterator = getPassengers().iterator(); while (iterator.hasNext()) { Entity entity = iterator.next(); entity.b(f, f1); }  }  return false; } public boolean isInWater() { return this.inWater; } public boolean isInRain() { BlockPosition blockposition = getChunkCoordinates(); return (this.world.isRainingAt(blockposition) || this.world.isRainingAt(new BlockPosition(blockposition.getX(), (getBoundingBox()).maxY, blockposition.getZ()))); } public final boolean isInBubbleColumn() { return k(); } private boolean k() { return this.world.getType(getChunkCoordinates()).a(Blocks.BUBBLE_COLUMN); } public boolean isInWaterOrRain() { return (isInWater() || isInRain()); } public final boolean isInWaterOrRainOrBubble() { return aF(); } public boolean aF() { return (isInWater() || isInRain() || k()); } public final boolean isInWaterOrBubbleColumn() { return aG(); } public boolean aG() { return (isInWater() || k()); } public boolean aH() { return (this.N && isInWater()); } public void aI() { if (isSwimming()) { setSwimming((isSprinting() && isInWater() && !isPassenger())); } else { setSwimming((isSprinting() && aH() && !isPassenger())); }  } protected boolean aJ() { this.M.clear(); aK(); double d0 = this.world.getDimensionManager().isNether() ? 0.007D : 0.0023333333333333335D; boolean flag = a(TagsFluid.LAVA, d0); return (isInWater() || flag); } void aK() { if (getVehicle() instanceof EntityBoat) { this.inWater = false; } else if (a(TagsFluid.WATER, 0.014D)) { if (!this.inWater && !this.justCreated) aL();  this.fallDistance = 0.0F; this.inWater = true; extinguish(); } else { this.inWater = false; }  } private void m() { Tag<FluidType> tag; this.N = a(TagsFluid.WATER); this.O = null; double d0 = getHeadY() - 0.1111111119389534D; Entity entity = getVehicle(); if (entity instanceof EntityBoat) { EntityBoat entityboat = (EntityBoat)entity; if (!entityboat.aH() && (entityboat.getBoundingBox()).maxY >= d0 && (entityboat.getBoundingBox()).minY <= d0) return;  }  BlockPosition blockposition = new BlockPosition(locX(), d0, locZ()); Fluid fluid = this.world.getFluid(blockposition); Iterator<? extends Tag.e<FluidType>> iterator = TagsFluid.b().iterator(); do { if (!iterator.hasNext()) return;  tag = iterator.next(); } while (!fluid.a(tag)); double d1 = (blockposition.getY() + fluid.getHeight(this.world, blockposition)); if (d1 > d0) this.O = tag;  } protected void aL() { Entity entity = (isVehicle() && getRidingPassenger() != null) ? getRidingPassenger() : this; float f = (entity == this) ? 0.2F : 0.9F; Vec3D vec3d = entity.getMot(); float f1 = MathHelper.sqrt(vec3d.x * vec3d.x * 0.20000000298023224D + vec3d.y * vec3d.y + vec3d.z * vec3d.z * 0.20000000298023224D) * f; if (f1 > 1.0F) f1 = 1.0F;  if (f1 < 0.25D) { playSound(getSoundSplash(), f1, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F); } else { playSound(getSoundSplashHighSpeed(), f1, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F); }  float f2 = MathHelper.floor(locY()); int i; for (i = 0; i < 1.0F + this.size.width * 20.0F; i++) { double d0 = (this.random.nextDouble() * 2.0D - 1.0D) * this.size.width; double d1 = (this.random.nextDouble() * 2.0D - 1.0D) * this.size.width; this.world.addParticle(Particles.BUBBLE, locX() + d0, (f2 + 1.0F), locZ() + d1, vec3d.x, vec3d.y - this.random.nextDouble() * 0.20000000298023224D, vec3d.z); }  for (i = 0; i < 1.0F + this.size.width * 20.0F; i++) { double d0 = (this.random.nextDouble() * 2.0D - 1.0D) * this.size.width; double d1 = (this.random.nextDouble() * 2.0D - 1.0D) * this.size.width; this.world.addParticle(Particles.SPLASH, locX() + d0, (f2 + 1.0F), locZ() + d1, vec3d.x, vec3d.y, vec3d.z); }  } protected IBlockData aM() { return this.world.getType(ao()); } public boolean aN() { return (isSprinting() && !isInWater() && !isSpectator() && !by() && !aP() && isAlive()); } protected void aO() { int i = MathHelper.floor(locX()); int j = MathHelper.floor(locY() - 0.20000000298023224D); int k = MathHelper.floor(locZ()); BlockPosition blockposition = new BlockPosition(i, j, k); IBlockData iblockdata = this.world.getType(blockposition); if (iblockdata.h() != EnumRenderType.INVISIBLE) { Vec3D vec3d = getMot(); this.world.addParticle(new ParticleParamBlock(Particles.BLOCK, iblockdata), locX() + (this.random.nextDouble() - 0.5D) * this.size.width, locY() + 0.1D, locZ() + (this.random.nextDouble() - 0.5D) * this.size.width, vec3d.x * -4.0D, 1.5D, vec3d.z * -4.0D); }  } public boolean a(Tag<FluidType> tag) { return (this.O == tag); } public final boolean isInLava() { return aP(); } public boolean aP() { return (!this.justCreated && this.M.getDouble(TagsFluid.LAVA) > 0.0D); } public void a(float f, Vec3D vec3d) { Vec3D vec3d1 = a(vec3d, f, this.yaw); setMot(getMot().e(vec3d1)); } private static Vec3D a(Vec3D vec3d, float f, float f1) { double d0 = vec3d.g(); if (d0 < 1.0E-7D) return Vec3D.ORIGIN;  Vec3D vec3d1 = ((d0 > 1.0D) ? vec3d.d() : vec3d).a(f); float f2 = MathHelper.sin(f1 * 0.017453292F); float f3 = MathHelper.cos(f1 * 0.017453292F); return new Vec3D(vec3d1.x * f3 - vec3d1.z * f2, vec3d1.y, vec3d1.z * f3 + vec3d1.x * f2); } public float aQ() { BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(locX(), 0.0D, locZ()); if (this.world.isLoaded(blockposition_mutableblockposition)) { blockposition_mutableblockposition.p(MathHelper.floor(getHeadY())); return this.world.y(blockposition_mutableblockposition); }  return 0.0F; } public void spawnIn(World world) { if (world == null) { die(); this.world = ((CraftWorld)Bukkit.getServer().getWorlds().get(0)).getHandle(); return; }  this.world = world; } public void setLocation(double d0, double d1, double d2, float f, float f1) { f(d0, d1, d2); this.yaw = f % 360.0F; this.pitch = MathHelper.a(f1, -90.0F, 90.0F) % 360.0F; this.lastYaw = this.yaw; this.lastPitch = this.pitch; } public void f(double d0, double d1, double d2) { double d3 = MathHelper.a(d0, -3.0E7D, 3.0E7D); double d4 = MathHelper.a(d2, -3.0E7D, 3.0E7D); this.lastX = d3; this.lastY = d1; this.lastZ = d4; setPosition(d3, d1, d4); if (this.valid) this.world.getChunkAt((int)Math.floor(locX()) >> 4, (int)Math.floor(locZ()) >> 4);  } public void d(Vec3D vec3d) { teleportAndSync(vec3d.x, vec3d.y, vec3d.z); } public void teleportAndSync(double d0, double d1, double d2) { setPositionRotation(d0, d1, d2, this.yaw, this.pitch); } public void setPositionRotation(BlockPosition blockposition, float f, float f1) { setPositionRotation(blockposition.getX() + 0.5D, blockposition.getY(), blockposition.getZ() + 0.5D, f, f1); } public void setPositionRotation(double d0, double d1, double d2, float f, float f1) { if (!this.preserveMotion) { this.mot = Vec3D.ORIGIN; } else { this.preserveMotion = false; }  g(d0, d1, d2); this.yaw = f; this.pitch = f1; ae(); } public void g(double d0, double d1, double d2) { setPositionRaw(d0, d1, d2); this.lastX = d0; this.lastY = d1; this.lastZ = d2; this.D = d0; this.E = d1; this.F = d2; } public float g(Entity entity) { float f = (float)(locX() - entity.locX()); float f1 = (float)(locY() - entity.locY()); float f2 = (float)(locZ() - entity.locZ()); return MathHelper.c(f * f + f1 * f1 + f2 * f2); } public double getDistanceSquared(double x, double y, double z) { return h(x, y, z); } public double h(double d0, double d1, double d2) { double d3 = locX() - d0; double d4 = locY() - d1; double d5 = locZ() - d2; return d3 * d3 + d4 * d4 + d5 * d5; } public double h(Entity entity) { return e(entity.getPositionVector()); } public double e(Vec3D vec3d) { double d0 = locX() - vec3d.x; double d1 = locY() - vec3d.y; double d2 = locZ() - vec3d.z; return d0 * d0 + d1 * d1 + d2 * d2; } public void pickup(EntityHuman entityhuman) {} public void collide(Entity entity) { if (!isSameVehicle(entity) && !entity.noclip && !this.noclip) { double d0 = entity.locX() - locX(); double d1 = entity.locZ() - locZ(); double d2 = MathHelper.a(d0, d1); if (d2 >= 0.009999999776482582D) { d2 = MathHelper.sqrt(d2); d0 /= d2; d1 /= d2; double d3 = 1.0D / d2; if (d3 > 1.0D) d3 = 1.0D;  d0 *= d3; d1 *= d3; d0 *= 0.05000000074505806D; d1 *= 0.05000000074505806D; d0 *= (1.0F - this.I); d1 *= (1.0F - this.I); if (!isVehicle()) i(-d0, 0.0D, -d1);  if (!entity.isVehicle()) entity.i(d0, 0.0D, d1);  }  }  } public void i(double d0, double d1, double d2) { setMot(getMot().add(d0, d1, d2)); this.impulse = true; } protected void velocityChanged() { this.velocityChanged = true; } public boolean damageEntity(DamageSource damagesource, float f) { if (isInvulnerable(damagesource)) return false;  velocityChanged(); return false; } public final Vec3D f(float f) { return c(g(f), h(f)); } public float g(float f) { return (f == 1.0F) ? this.pitch : MathHelper.g(f, this.lastPitch, this.pitch); } public float h(float f) { return (f == 1.0F) ? this.yaw : MathHelper.g(f, this.lastYaw, this.yaw); } protected final Vec3D c(float f, float f1) { float f2 = f * 0.017453292F; float f3 = -f1 * 0.017453292F; float f4 = MathHelper.cos(f3); float f5 = MathHelper.sin(f3); float f6 = MathHelper.cos(f2); float f7 = MathHelper.sin(f2); return new Vec3D((f5 * f6), -f7, (f4 * f6)); } public final Vec3D i(float f) { return d(g(f), h(f)); } protected final Vec3D d(float f, float f1) { return c(f - 90.0F, f1); } public final Vec3D getEyePosition(float partialTicks) { return j(partialTicks); } public final Vec3D j(float f) { if (f == 1.0F) return new Vec3D(locX(), getHeadY(), locZ());  double d0 = MathHelper.d(f, this.lastX, locX()); double d1 = MathHelper.d(f, this.lastY, locY()) + getHeadHeight(); double d2 = MathHelper.d(f, this.lastZ, locZ()); return new Vec3D(d0, d1, d2); } public MovingObjectPosition a(double d0, float f, boolean flag) { Vec3D vec3d = j(f); Vec3D vec3d1 = f(f); Vec3D vec3d2 = vec3d.add(vec3d1.x * d0, vec3d1.y * d0, vec3d1.z * d0); return this.world.rayTrace(new RayTrace(vec3d, vec3d2, RayTrace.BlockCollisionOption.OUTLINE, flag ? RayTrace.FluidCollisionOption.ANY : RayTrace.FluidCollisionOption.NONE, this)); } public boolean isInteractable() { return false; } public boolean isCollidable() { return false; } public boolean canCollideWith(Entity entity) { return isCollidable(); } public final void runKillTrigger(Entity entity, int kills, DamageSource damageSource) { a(entity, kills, damageSource); } public void a(Entity entity, int i, DamageSource damagesource) { if (entity instanceof EntityPlayer) CriterionTriggers.c.a((EntityPlayer)entity, this, damagesource);  } public boolean a_(NBTTagCompound nbttagcompound) { String s = getSaveID(); if (this.persist && !this.dead && s != null) { nbttagcompound.setString("id", s); save(nbttagcompound); return true; }  return false; } public boolean d(NBTTagCompound nbttagcompound) { return isPassenger() ? false : a_(nbttagcompound); } public NBTTagCompound save(NBTTagCompound nbttagcompound) { try { if (this.vehicle != null) { nbttagcompound.set("Pos", a(new double[] { this.vehicle.locX(), locY(), this.vehicle.locZ() })); } else { nbttagcompound.set("Pos", a(new double[] { locX(), locY(), locZ() })); }  Vec3D vec3d = getMot(); nbttagcompound.set("Motion", a(new double[] { vec3d.x, vec3d.y, vec3d.z })); if (Float.isNaN(this.yaw)) this.yaw = 0.0F;  if (Float.isNaN(this.pitch)) this.pitch = 0.0F;  nbttagcompound.set("Rotation", a(new float[] { this.yaw, this.pitch })); nbttagcompound.setFloat("FallDistance", this.fallDistance); nbttagcompound.setShort("Fire", (short)this.fireTicks); nbttagcompound.setShort("Air", (short)getAirTicks()); nbttagcompound.setBoolean("OnGround", this.onGround); nbttagcompound.setBoolean("Invulnerable", this.invulnerable); nbttagcompound.setInt("PortalCooldown", this.portalCooldown); nbttagcompound.a("UUID", getUniqueID()); nbttagcompound.setLong("WorldUUIDLeast", ((WorldServer)this.world).getWorld().getUID().getLeastSignificantBits()); nbttagcompound.setLong("WorldUUIDMost", ((WorldServer)this.world).getWorld().getUID().getMostSignificantBits()); nbttagcompound.setInt("Bukkit.updateLevel", 2); if (!this.persist) nbttagcompound.setBoolean("Bukkit.persist", this.persist);  if (this.persistentInvisibility) nbttagcompound.setBoolean("Bukkit.invisible", this.persistentInvisibility);  nbttagcompound.setInt("Spigot.ticksLived", this.ticksLived); IChatBaseComponent ichatbasecomponent = getCustomName(); if (ichatbasecomponent != null) nbttagcompound.setString("CustomName", IChatBaseComponent.ChatSerializer.a(ichatbasecomponent));  if (getCustomNameVisible()) nbttagcompound.setBoolean("CustomNameVisible", getCustomNameVisible());  if (isSilent()) nbttagcompound.setBoolean("Silent", isSilent());  if (isNoGravity()) nbttagcompound.setBoolean("NoGravity", isNoGravity());  if (this.glowing) nbttagcompound.setBoolean("Glowing", this.glowing);  if (!this.ay.isEmpty()) { NBTTagList nbttaglist = new NBTTagList(); Iterator<String> iterator = this.ay.iterator(); while (iterator.hasNext()) { String s = iterator.next(); nbttaglist.add(NBTTagString.a(s)); }  nbttagcompound.set("Tags", nbttaglist); }  saveData(nbttagcompound); if (isVehicle()) { NBTTagList nbttaglist = new NBTTagList(); Iterator<Entity> iterator = getPassengers().iterator(); while (iterator.hasNext()) { Entity entity = iterator.next(); NBTTagCompound nbttagcompound1 = new NBTTagCompound(); if (entity.a_(nbttagcompound1)) nbttaglist.add(nbttagcompound1);  }  if (!nbttaglist.isEmpty()) nbttagcompound.set("Passengers", nbttaglist);  }  if (this.bukkitEntity != null) this.bukkitEntity.storeBukkitValues(nbttagcompound);  if (this.origin != null) nbttagcompound.set("Paper.Origin", createList(new double[] { this.origin.getX(), this.origin.getY(), this.origin.getZ() }));  if (this.spawnReason != null) nbttagcompound.setString("Paper.SpawnReason", this.spawnReason.name());  if (this.spawnedViaMobSpawner) nbttagcompound.setBoolean("Paper.FromMobSpawner", true);  if (this.fromNetherPortal) nbttagcompound.setBoolean("Paper.FromNetherPortal", true);  return nbttagcompound; } catch (Throwable throwable) { CrashReport crashreport = CrashReport.a(throwable, "Saving entity NBT"); CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being saved"); appendEntityCrashDetails(crashreportsystemdetails); throw new ReportedException(crashreport); }  } public void load(NBTTagCompound nbttagcompound) { try { NBTTagList nbttaglist = nbttagcompound.getList("Pos", 6); NBTTagList nbttaglist1 = nbttagcompound.getList("Motion", 6); NBTTagList nbttaglist2 = nbttagcompound.getList("Rotation", 5); double d0 = nbttaglist1.h(0); double d1 = nbttaglist1.h(1); double d2 = nbttaglist1.h(2); setMot((Math.abs(d0) > 10.0D) ? 0.0D : d0, (Math.abs(d1) > 10.0D) ? 0.0D : d1, (Math.abs(d2) > 10.0D) ? 0.0D : d2); g(nbttaglist.h(0), nbttaglist.h(1), nbttaglist.h(2)); this.yaw = nbttaglist2.i(0); this.pitch = nbttaglist2.i(1); this.lastYaw = this.yaw; this.lastPitch = this.pitch; setHeadRotation(this.yaw); n(this.yaw); this.fallDistance = nbttagcompound.getFloat("FallDistance"); this.fireTicks = nbttagcompound.getShort("Fire"); setAirTicks(nbttagcompound.getShort("Air")); this.onGround = nbttagcompound.getBoolean("OnGround"); this.invulnerable = nbttagcompound.getBoolean("Invulnerable"); this.portalCooldown = nbttagcompound.getInt("PortalCooldown"); if (nbttagcompound.b("UUID")) { this.uniqueID = nbttagcompound.a("UUID"); this.ae = this.uniqueID.toString(); }  if (Double.isFinite(locX()) && Double.isFinite(locY()) && Double.isFinite(locZ())) { if (Double.isFinite(this.yaw) && Double.isFinite(this.pitch)) { ae(); setYawPitch(this.yaw, this.pitch); if (nbttagcompound.hasKeyOfType("CustomName", 8)) { String s = nbttagcompound.getString("CustomName"); try { setCustomName(IChatBaseComponent.ChatSerializer.a(s)); } catch (Exception exception) { LOGGER.warn("Failed to parse entity custom name {}", s, exception); }  }  setCustomNameVisible(nbttagcompound.getBoolean("CustomNameVisible")); setSilent(nbttagcompound.getBoolean("Silent")); setNoGravity(nbttagcompound.getBoolean("NoGravity")); i(nbttagcompound.getBoolean("Glowing")); if (nbttagcompound.hasKeyOfType("Tags", 9)) { this.ay.clear(); NBTTagList nbttaglist3 = nbttagcompound.getList("Tags", 8); int i = Math.min(nbttaglist3.size(), 1024); for (int j = 0; j < i; j++) this.ay.add(nbttaglist3.getString(j));  }  loadData(nbttagcompound); if (aU()) ae();  } else { throw new IllegalStateException("Entity has invalid rotation"); }  } else { throw new IllegalStateException("Entity has invalid position"); }  if (this instanceof EntityLiving) { EntityLiving entity = (EntityLiving)this; this.ticksLived = nbttagcompound.getInt("Spigot.ticksLived"); if (entity instanceof EntityTameableAnimal && !isLevelAtLeast(nbttagcompound, 2) && !nbttagcompound.getBoolean("PersistenceRequired")) { EntityInsentient entityinsentient = (EntityInsentient)entity; entityinsentient.persistent = !entityinsentient.isTypeNotPersistent(0.0D); }  }  this.persist = (!nbttagcompound.hasKey("Bukkit.persist") || nbttagcompound.getBoolean("Bukkit.persist")); if (this instanceof EntityPlayer) { Server server = Bukkit.getServer(); World bworld = null; String worldName = nbttagcompound.getString("world"); if (nbttagcompound.hasKey("WorldUUIDMost") && nbttagcompound.hasKey("WorldUUIDLeast")) { UUID uid = new UUID(nbttagcompound.getLong("WorldUUIDMost"), nbttagcompound.getLong("WorldUUIDLeast")); bworld = server.getWorld(uid); } else { bworld = server.getWorld(worldName); }  spawnIn((bworld == null) ? null : ((CraftWorld)bworld).getHandle()); }  getBukkitEntity().readBukkitValues(nbttagcompound); if (nbttagcompound.hasKey("Bukkit.invisible")) { boolean bukkitInvisible = nbttagcompound.getBoolean("Bukkit.invisible"); setInvisible(bukkitInvisible); this.persistentInvisibility = bukkitInvisible; }  NBTTagList originTag = nbttagcompound.getList("Paper.Origin", 6); if (!originTag.isEmpty()) this.origin = new Location((World)this.world.getWorld(), originTag.getDoubleAt(0), originTag.getDoubleAt(1), originTag.getDoubleAt(2));  this.spawnedViaMobSpawner = nbttagcompound.getBoolean("Paper.FromMobSpawner"); this.fromNetherPortal = nbttagcompound.getBoolean("Paper.FromNetherPortal"); if (nbttagcompound.hasKey("Paper.SpawnReason")) { String spawnReasonName = nbttagcompound.getString("Paper.SpawnReason"); try { this.spawnReason = CreatureSpawnEvent.SpawnReason.valueOf(spawnReasonName); } catch (Exception ignored) { LogManager.getLogger().error("Unknown SpawnReason " + spawnReasonName + " for " + this); }  }  if (this.spawnReason == null) if (this.spawnedViaMobSpawner) { this.spawnReason = CreatureSpawnEvent.SpawnReason.SPAWNER; } else if (this instanceof EntityInsentient && (this instanceof EntityAnimal || this instanceof EntityFish) && !((EntityInsentient)this).isTypeNotPersistent(0.0D) && !nbttagcompound.getBoolean("PersistenceRequired")) { this.spawnReason = CreatureSpawnEvent.SpawnReason.NATURAL; }   if (this.spawnReason == null) this.spawnReason = CreatureSpawnEvent.SpawnReason.DEFAULT;  } catch (Throwable throwable) { CrashReport crashreport = CrashReport.a(throwable, "Loading entity NBT"); CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being loaded"); appendEntityCrashDetails(crashreportsystemdetails); throw new ReportedException(crashreport); }  } protected boolean aU() { return true; } public void setCurrentChunk(Chunk chunk) { this.currentChunk = (chunk != null) ? new WeakReference<>(chunk) : null; } public Chunk getCurrentChunk() { Chunk chunk = (this.currentChunk != null) ? this.currentChunk.get() : null; if (chunk != null && chunk.loaded) return chunk;  return !this.inChunk ? null : ((WorldServer)this.world).getChunkProvider().getChunkAtIfLoadedMainThreadNoCache(this.chunkX, this.chunkZ); } public MinecraftKey getMinecraftKey() { if (this.entityKey == null) { this.entityKey = EntityTypes.getName(getEntityType()); this.entityKeyString = (this.entityKey != null) ? this.entityKey.toString() : null; }  return this.entityKey; } public String getMinecraftKeyString() { getMinecraftKey(); return this.entityKeyString; } @Nullable public final String getSaveID() { EntityTypes<?> entitytypes = getEntityType(); MinecraftKey minecraftkey = EntityTypes.getName(entitytypes); return (entitytypes != null && entitytypes.isPersistable()) ? getMinecraftKeyString() : null; } protected final NBTTagList createList(double... adouble) { return a(adouble); } protected NBTTagList a(double... adouble) { NBTTagList nbttaglist = new NBTTagList(); double[] adouble1 = adouble; int i = adouble.length; for (int j = 0; j < i; j++) { double d0 = adouble1[j]; nbttaglist.add(NBTTagDouble.a(d0)); }  return nbttaglist; } protected NBTTagList a(float... afloat) { NBTTagList nbttaglist = new NBTTagList(); float[] afloat1 = afloat; int i = afloat.length; for (int j = 0; j < i; j++) { float f = afloat1[j]; nbttaglist.add(NBTTagFloat.a(f)); }  return nbttaglist; } @Nullable public EntityItem a(IMaterial imaterial) { return a(imaterial, 0); } @Nullable public EntityItem a(IMaterial imaterial, int i) { return a(new ItemStack(imaterial), i); } @Nullable public EntityItem a(ItemStack itemstack) { return a(itemstack, 0.0F); } @Nullable public final EntityItem dropItem(ItemStack itemstack, float offset) { return a(itemstack, offset); } @Nullable public EntityItem a(ItemStack itemstack, float f) { if (itemstack.isEmpty()) return null;  if (this.world.isClientSide) return null;  if (this instanceof EntityLiving && !((EntityLiving)this).forceDrops) { ((EntityLiving)this).drops.add(CraftItemStack.asCraftMirror(itemstack)); return null; }  EntityItem entityitem = new EntityItem(this.world, locX(), locY() + f, locZ(), itemstack.cloneItemStack()); itemstack.setCount(0); entityitem.defaultPickupDelay(); EntityDropItemEvent event = new EntityDropItemEvent((org.bukkit.entity.Entity)getBukkitEntity(), (Item)entityitem.getBukkitEntity()); Bukkit.getPluginManager().callEvent((Event)event); if (event.isCancelled()) return null;  this.world.addEntity(entityitem); return entityitem; } public boolean isAlive() { return !this.dead; } public boolean inBlock() { if (this.noclip) return false;  float f = 0.1F; float f1 = this.size.width * 0.8F; AxisAlignedBB axisalignedbb = AxisAlignedBB.g(f1, 0.10000000149011612D, f1).d(locX(), getHeadY(), locZ()); return this.world.b(this, axisalignedbb, (iblockdata, blockposition) -> iblockdata.o(this.world, blockposition)).findAny().isPresent(); } public EnumInteractionResult a(EntityHuman entityhuman, EnumHand enumhand) { return EnumInteractionResult.PASS; } public final boolean hardCollidesWith(Entity other) { return j(other); } public boolean j(Entity entity) { return (entity.aY() && !isSameVehicle(entity)); } public final boolean collisionBoxIsHard() { return aY(); } public boolean aY() { return false; } public Vec3D getMot() { return this.mot; }
/*      */   public void passengerTick() { setMot(Vec3D.ORIGIN); tick(); if (isPassenger()) getVehicle().k(this);  }
/*      */   public void syncPositionOf(Entity entity) { k(entity); }
/*      */   public void k(Entity entity) { a(entity, Entity::setPosition); }
/* 3514 */   private void a(Entity entity, a entity_a) { if (w(entity)) { double d0 = locY() + bb() + entity.ba(); entity_a.accept(entity, locX(), d0, locZ()); }  } public double ba() { return 0.0D; } public double bb() { return this.size.height * 0.75D; } public boolean startRiding(Entity entity) { return a(entity, false); } public boolean a(Entity entity, boolean flag) { for (Entity entity1 = entity; entity1.vehicle != null; entity1 = entity1.vehicle) { if (entity1.vehicle == this) return false;  }  if (!flag && (!n(entity) || !entity.q(this))) return false;  if (isPassenger()) stopRiding();  setPose(EntityPose.STANDING); this.vehicle = entity; if (!this.vehicle.addPassenger(this)) this.vehicle = null;  return true; } protected boolean n(Entity entity) { return (!isSneaking() && this.j <= 0); } protected boolean c(EntityPose entitypose) { return this.world.getCubes(this, d(entitypose).shrink(1.0E-7D)); } public void ejectPassengers() { for (int i = this.passengers.size() - 1; i >= 0; i--) ((Entity)this.passengers.get(i)).stopRiding();  } public void be() { stopRiding(false); } public void stopRiding(boolean suppressCancellation) { if (this.vehicle != null) { Entity entity = this.vehicle; this.vehicle = null; if (!entity.removePassenger(this, suppressCancellation)) this.vehicle = entity;  }  } public void stopRiding() { be(); } protected boolean addPassenger(Entity entity) { if (entity == this) throw new IllegalArgumentException("Entities cannot become a passenger of themselves");  if (entity.getVehicle() != this) throw new IllegalStateException("Use x.startRiding(y), not y.addPassenger(x)");  Preconditions.checkState(!entity.passengers.contains(this), "Circular entity riding! %s %s", this, entity); CraftEntity craft = (CraftEntity)entity.getBukkitEntity().getVehicle(); Entity orig = (craft == null) ? null : craft.getHandle(); if (getBukkitEntity() instanceof Vehicle && entity.getBukkitEntity() instanceof LivingEntity) { VehicleEnterEvent vehicleEnterEvent = new VehicleEnterEvent((Vehicle)getBukkitEntity(), (org.bukkit.entity.Entity)entity.getBukkitEntity()); if (this.valid) Bukkit.getPluginManager().callEvent((Event)vehicleEnterEvent);  CraftEntity craftn = (CraftEntity)entity.getBukkitEntity().getVehicle(); Entity n = (craftn == null) ? null : craftn.getHandle(); if (vehicleEnterEvent.isCancelled() || n != orig) return false;  }  EntityMountEvent event = new EntityMountEvent((org.bukkit.entity.Entity)entity.getBukkitEntity(), (org.bukkit.entity.Entity)getBukkitEntity()); if (this.valid) Bukkit.getPluginManager().callEvent((Event)event);  if (event.isCancelled()) return false;  if (!this.world.isClientSide && entity instanceof EntityHuman && !(getRidingPassenger() instanceof EntityHuman)) { this.passengers.add(0, entity); } else { this.passengers.add(entity); }  return true; } protected boolean removePassenger(Entity entity) { return removePassenger(entity, false); } protected boolean removePassenger(Entity entity, boolean suppressCancellation) { if (entity.getVehicle() == this) throw new IllegalStateException("Use x.stopRiding(y), not y.removePassenger(x)");  CraftEntity craft = (CraftEntity)entity.getBukkitEntity().getVehicle(); Entity orig = (craft == null) ? null : craft.getHandle(); if (getBukkitEntity() instanceof Vehicle && entity.getBukkitEntity() instanceof LivingEntity) { VehicleExitEvent vehicleExitEvent = new VehicleExitEvent((Vehicle)getBukkitEntity(), (LivingEntity)entity.getBukkitEntity(), !suppressCancellation); if (this.valid) Bukkit.getPluginManager().callEvent((Event)vehicleExitEvent);  CraftEntity craftn = (CraftEntity)entity.getBukkitEntity().getVehicle(); Entity n = (craftn == null) ? null : craftn.getHandle(); if (vehicleExitEvent.isCancelled() || n != orig) return false;  }  EntityDismountEvent event = new EntityDismountEvent((org.bukkit.entity.Entity)entity.getBukkitEntity(), (org.bukkit.entity.Entity)getBukkitEntity(), !suppressCancellation); if (this.valid) Bukkit.getPluginManager().callEvent((Event)event);  if (event.isCancelled()) return false;  this.passengers.remove(entity); entity.j = 60; return true; } protected boolean q(Entity entity) { return (getPassengers().size() < 1); } public final float getCollisionBorderSize() { return bf(); } public float bf() { return 0.0F; } public Vec3D getLookDirection() { return c(this.pitch, this.yaw); } public Vec2F bh() { return new Vec2F(this.pitch, this.yaw); } public void d(BlockPosition blockposition) { if (ah()) { resetPortalCooldown(); } else { if (!this.world.isClientSide && !blockposition.equals(this.ac)) this.ac = blockposition.immutableCopy();  this.inPortal = true; }  } protected void doPortalTick() { if (this.world instanceof WorldServer) { int i = ai(); WorldServer worldserver = (WorldServer)this.world; if (this.inPortal) { MinecraftServer minecraftserver = worldserver.getMinecraftServer(); ResourceKey<World> resourcekey = (this.world.getDimensionKey() == World.THE_NETHER) ? World.OVERWORLD : World.THE_NETHER; WorldServer worldserver1 = minecraftserver.getWorldServer(resourcekey); if (!isPassenger() && this.portalTicks++ >= i) { this.world.getMethodProfiler().enter("portal"); this.portalTicks = i; resetPortalCooldown(); if (this instanceof EntityPlayer) { ((EntityPlayer)this).b(worldserver1, PlayerTeleportEvent.TeleportCause.NETHER_PORTAL); } else { b(worldserver1); }  this.world.getMethodProfiler().exit(); }  this.inPortal = false; } else { if (this.portalTicks > 0) this.portalTicks -= 4;  if (this.portalTicks < 0) this.portalTicks = 0;  }  E(); }  } public int getDefaultPortalCooldown() { return 300; } public Iterable<ItemStack> bm() { return c; } public Iterable<ItemStack> getArmorItems() { return c; } public Iterable<ItemStack> bo() { return Iterables.concat(bm(), getArmorItems()); } public void setSlot(EnumItemSlot enumitemslot, ItemStack itemstack) {} public boolean isBurning() { boolean flag = (this.world != null && this.world.isClientSide); return (!isFireProof() && (this.fireTicks > 0 || (flag && getFlag(0)))); } public boolean isPassenger() { return (getVehicle() != null); } public boolean isVehicle() { return !getPassengers().isEmpty(); } public boolean bs() { return true; } public void setSneaking(boolean flag) { setFlag(1, flag); } public boolean isSneaking() { return getFlag(1); } public boolean bu() { return isSneaking(); } public boolean bv() { return isSneaking(); } public boolean bw() { return isSneaking(); } public boolean bx() { return isSneaking(); } public boolean by() { return (getPose() == EntityPose.CROUCHING); } public boolean isSprinting() { return getFlag(3); } public void setSprinting(boolean flag) { setFlag(3, flag); } public boolean isSwimming() { return getFlag(4); } public boolean bB() { return (getPose() == EntityPose.SWIMMING); } public void setSwimming(boolean flag) { if (isSwimming() != flag && this instanceof EntityLiving && CraftEventFactory.callToggleSwimEvent((EntityLiving)this, flag).isCancelled()) return;  setFlag(4, flag); } public boolean bD() { return (this.glowing || (this.world.isClientSide && getFlag(6))); } public void i(boolean flag) { this.glowing = flag; if (!this.world.isClientSide) setFlag(6, this.glowing);  } public boolean isInvisible() { return getFlag(5); } @Nullable public ScoreboardTeamBase getScoreboardTeam() { if (!this.world.paperConfig.nonPlayerEntitiesOnScoreboards && !(this instanceof EntityHuman)) return null;  return this.world.getScoreboard().getPlayerTeam(getName()); } public boolean r(Entity entity) { return a(entity.getScoreboardTeam()); } public boolean a(ScoreboardTeamBase scoreboardteambase) { return (getScoreboardTeam() != null) ? getScoreboardTeam().isAlly(scoreboardteambase) : false; } public void setInvisible(boolean flag) { if (!this.persistentInvisibility) setFlag(5, flag);  } public boolean getFlag(int i) { return ((((Byte)this.datawatcher.<Byte>get(S)).byteValue() & 1 << i) != 0); } public void setFlag(int i, boolean flag) { byte b0 = ((Byte)this.datawatcher.<Byte>get(S)).byteValue(); if (flag) { this.datawatcher.set(S, Byte.valueOf((byte)(b0 | 1 << i))); } else { this.datawatcher.set(S, Byte.valueOf((byte)(b0 & (1 << i ^ 0xFFFFFFFF)))); }  } public final int getMaxAirTicks() { return bG(); } public int bG() { return 300; } public int getAirTicks() { return ((Integer)this.datawatcher.<Integer>get(AIR_TICKS)).intValue(); } public void setAirTicks(int i) { EntityAirChangeEvent event = new EntityAirChangeEvent((org.bukkit.entity.Entity)getBukkitEntity(), i); if (this.valid) event.getEntity().getServer().getPluginManager().callEvent((Event)event);  if (event.isCancelled()) return;  this.datawatcher.set(AIR_TICKS, Integer.valueOf(event.getAmount())); } public void onLightningStrike(WorldServer worldserver, EntityLightning entitylightning) { setFireTicks(this.fireTicks + 1); CraftEntity craftEntity1 = getBukkitEntity(); CraftEntity craftEntity2 = entitylightning.getBukkitEntity(); PluginManager pluginManager = Bukkit.getPluginManager(); if (this.fireTicks == 0) { EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent((org.bukkit.entity.Entity)craftEntity2, (org.bukkit.entity.Entity)craftEntity1, 8); pluginManager.callEvent((Event)entityCombustEvent); if (!entityCombustEvent.isCancelled()) setOnFire(entityCombustEvent.getDuration(), false);  }  if (craftEntity1 instanceof Hanging) { HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging)craftEntity1, (org.bukkit.entity.Entity)craftEntity2); pluginManager.callEvent((Event)hangingEvent); if (hangingEvent.isCancelled()) return;  }  if (isFireProof()) return;  CraftEventFactory.entityDamage = entitylightning; if (!damageEntity(DamageSource.LIGHTNING, 5.0F)) { CraftEventFactory.entityDamage = null; return; }  } public void k(boolean flag) { double d0; Vec3D vec3d = getMot(); if (flag) { d0 = Math.max(-0.9D, vec3d.y - 0.03D); } else { d0 = Math.min(1.8D, vec3d.y + 0.1D); }  setMot(vec3d.x, d0, vec3d.z); } public void l(boolean flag) { double d0; Vec3D vec3d = getMot(); if (flag) { d0 = Math.max(-0.3D, vec3d.y - 0.03D); } else { d0 = Math.min(0.7D, vec3d.y + 0.06D); }  setMot(vec3d.x, d0, vec3d.z); this.fallDistance = 0.0F; } public final void onKill(WorldServer worldserver, EntityLiving entityLiving) { a(worldserver, entityLiving); } public void a(WorldServer worldserver, EntityLiving entityliving) {} protected void l(double d0, double d1, double d2) { BlockPosition blockposition = new BlockPosition(d0, d1, d2); Vec3D vec3d = new Vec3D(d0 - blockposition.getX(), d1 - blockposition.getY(), d2 - blockposition.getZ()); BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(); EnumDirection enumdirection = EnumDirection.UP; double d3 = Double.MAX_VALUE; EnumDirection[] aenumdirection = { EnumDirection.NORTH, EnumDirection.SOUTH, EnumDirection.WEST, EnumDirection.EAST, EnumDirection.UP }; int i = aenumdirection.length; for (int j = 0; j < i; j++) { EnumDirection enumdirection1 = aenumdirection[j]; blockposition_mutableblockposition.a(blockposition, enumdirection1); if (!this.world.getType(blockposition_mutableblockposition).r(this.world, blockposition_mutableblockposition)) { double d4 = vec3d.a(enumdirection1.n()); double d5 = (enumdirection1.e() == EnumDirection.EnumAxisDirection.POSITIVE) ? (1.0D - d4) : d4; if (d5 < d3) { d3 = d5; enumdirection = enumdirection1; }  }  }  float f = this.random.nextFloat() * 0.2F + 0.1F; float f1 = enumdirection.e().a(); Vec3D vec3d1 = getMot().a(0.75D); if (enumdirection.n() == EnumDirection.EnumAxis.X) { setMot((f1 * f), vec3d1.y, vec3d1.z); } else if (enumdirection.n() == EnumDirection.EnumAxis.Y) { setMot(vec3d1.x, (f1 * f), vec3d1.z); } else if (enumdirection.n() == EnumDirection.EnumAxis.Z) { setMot(vec3d1.x, vec3d1.y, (f1 * f)); }  } public void a(IBlockData iblockdata, Vec3D vec3d) { this.fallDistance = 0.0F; this.x = vec3d; } private static IChatBaseComponent b(IChatBaseComponent ichatbasecomponent) { IChatMutableComponent ichatmutablecomponent = ichatbasecomponent.g().setChatModifier(ichatbasecomponent.getChatModifier().setChatClickable((ChatClickable)null)); Iterator<IChatBaseComponent> iterator = ichatbasecomponent.getSiblings().iterator(); while (iterator.hasNext()) { IChatBaseComponent ichatbasecomponent1 = iterator.next(); ichatmutablecomponent.addSibling(b(ichatbasecomponent1)); }  return ichatmutablecomponent; } public IChatBaseComponent getDisplayName() { IChatBaseComponent ichatbasecomponent = getCustomName(); return (ichatbasecomponent != null) ? b(ichatbasecomponent) : bI(); } protected IChatBaseComponent bI() { return this.f.g(); } public boolean s(Entity entity) { return (this == entity); } public float getHeadRotation() { return 0.0F; } public void setHeadRotation(float f) {} public void n(float f) {} public boolean bK() { return true; } public boolean t(Entity entity) { return false; } public String toString() { return String.format(Locale.ROOT, "%s['%s'/%d, uuid='%s', l='%s', x=%.2f, y=%.2f, z=%.2f, cx=%d, cz=%d, tl=%d, v=%b, d=%b]", new Object[] { getClass().getSimpleName(), getDisplayName().getString(), Integer.valueOf(this.id), this.uniqueID.toString(), (this.world == null) ? "~NULL~" : this.world.toString(), Double.valueOf(locX()), Double.valueOf(locY()), Double.valueOf(locZ()), Integer.valueOf(this.chunkX), Integer.valueOf(this.chunkZ), Integer.valueOf(this.ticksLived), Boolean.valueOf(this.valid), Boolean.valueOf(this.dead) }); } public boolean isInvulnerable(DamageSource damagesource) { return (this.invulnerable && damagesource != DamageSource.OUT_OF_WORLD && !damagesource.v()); } public boolean isInvulnerable() { return this.invulnerable; } public void setInvulnerable(boolean flag) { this.invulnerable = flag; } public void u(Entity entity) { setPositionRotation(entity.locX(), entity.locY(), entity.locZ(), entity.yaw, entity.pitch); } public void v(Entity entity) { NBTTagCompound nbttagcompound = entity.save(new NBTTagCompound()); nbttagcompound.remove("Dimension"); load(nbttagcompound); this.portalCooldown = entity.portalCooldown; this.ac = entity.ac; } @Nullable public Entity b(WorldServer worldserver) { return teleportTo(worldserver, null); } @Nullable public Entity teleportTo(WorldServer worldserver, BlockPosition location) { if (!isAlive() || !this.valid) { LOGGER.warn("Illegal Entity Teleport " + this + " to " + worldserver + ":" + location, new Throwable()); return null; }  if (this.world instanceof WorldServer && !this.dead) { this.world.getMethodProfiler().enter("changeDimension"); if (worldserver == null) return null;  this.world.getMethodProfiler().enter("reposition"); ShapeDetectorShape shapedetectorshape = (location == null) ? a(worldserver) : new ShapeDetectorShape(new Vec3D(location.getX(), location.getY(), location.getZ()), Vec3D.ORIGIN, this.yaw, this.pitch, worldserver, null); if (shapedetectorshape == null) return null;  worldserver = shapedetectorshape.world; decouple(); this.world.getMethodProfiler().exitEnter("reloading"); Entity entity = (Entity)getEntityType().a(worldserver); if (entity != null) { entity.v(this); entity.setPositionRotation(shapedetectorshape.position.x, shapedetectorshape.position.y, shapedetectorshape.position.z, shapedetectorshape.yaw, entity.pitch); entity.setMot(shapedetectorshape.velocity); worldserver.addEntityTeleport(entity); if (worldserver.getTypeKey() == DimensionManager.THE_END) WorldServer.a(worldserver, this);  getBukkitEntity().setHandle(entity); entity.bukkitEntity = getBukkitEntity(); if (this instanceof EntityInsentient) ((EntityInsentient)this).unleash(true, true);  }  bM(); this.world.getMethodProfiler().exit(); ((WorldServer)this.world).resetEmptyTime(); worldserver.resetEmptyTime(); this.world.getMethodProfiler().exit(); return entity; }  return null; } protected void bM() { this.dead = true; } @Nullable protected ShapeDetectorShape a(WorldServer worldserver) { if (worldserver == null) return null;  boolean flag = (this.world.getTypeKey() == DimensionManager.THE_END && worldserver.getTypeKey() == DimensionManager.OVERWORLD); boolean flag1 = (worldserver.getTypeKey() == DimensionManager.THE_END); if (!flag && !flag1) { boolean flag2 = (worldserver.getTypeKey() == DimensionManager.THE_NETHER); if (this.world.getTypeKey() != DimensionManager.THE_NETHER && !flag2) return null;  WorldBorder worldborder = worldserver.getWorldBorder(); double d0 = Math.max(-2.9999872E7D, worldborder.e() + 16.0D); double d1 = Math.max(-2.9999872E7D, worldborder.f() + 16.0D); double d2 = Math.min(2.9999872E7D, worldborder.g() - 16.0D); double d3 = Math.min(2.9999872E7D, worldborder.h() - 16.0D); double d4 = DimensionManager.a(this.world.getDimensionManager(), worldserver.getDimensionManager()); BlockPosition blockposition = new BlockPosition(MathHelper.a(locX() * d4, d0, d2), locY(), MathHelper.a(locZ() * d4, d1, d3)); CraftPortalEvent craftPortalEvent = callPortalEvent(this, worldserver, blockposition, PlayerTeleportEvent.TeleportCause.NETHER_PORTAL, worldserver.paperConfig.portalSearchRadius, worldserver.paperConfig.portalCreateRadius); if (craftPortalEvent == null) return null;  WorldServer worldserverFinal = worldserver = ((CraftWorld)craftPortalEvent.getTo().getWorld()).getHandle(); blockposition = new BlockPosition(craftPortalEvent.getTo().getX(), craftPortalEvent.getTo().getY(), craftPortalEvent.getTo().getZ()); return a(worldserver, blockposition, flag2, craftPortalEvent.getSearchRadius(), craftPortalEvent.getCanCreatePortal(), craftPortalEvent.getCreationRadius()).<ShapeDetectorShape>map(blockutil_rectangle -> { EnumDirection.EnumAxis enumdirection_enumaxis; Vec3D vec3d; IBlockData iblockdata = this.world.getType(this.ac); if (iblockdata.b(BlockProperties.E)) { enumdirection_enumaxis = (EnumDirection.EnumAxis)iblockdata.get(BlockProperties.E); BlockUtil.Rectangle blockutil_rectangle1 = BlockUtil.a(this.ac, enumdirection_enumaxis, 21, EnumDirection.EnumAxis.Y, 21, ()); vec3d = a(enumdirection_enumaxis, blockutil_rectangle1); } else { enumdirection_enumaxis = EnumDirection.EnumAxis.X; vec3d = new Vec3D(0.5D, 0.0D, 0.0D); }  return BlockPortalShape.a(worldserverFinal, blockutil_rectangle, enumdirection_enumaxis, vec3d, a(getPose()), getMot(), this.yaw, this.pitch, event); }).orElse(null); }  if (flag1) { this.world.getChunkAtWorldCoords(this.world.getSpawn()); blockposition1 = WorldServer.a; } else { blockposition1 = worldserver.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING_NO_LEAVES, worldserver.getSpawn()); }  CraftPortalEvent event = callPortalEvent(this, worldserver, blockposition1, PlayerTeleportEvent.TeleportCause.END_PORTAL, 0, 0); if (event == null) return null;  BlockPosition blockposition1 = new BlockPosition(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ()); return new ShapeDetectorShape(new Vec3D(blockposition1.getX() + 0.5D, blockposition1.getY(), blockposition1.getZ() + 0.5D), getMot(), this.yaw, this.pitch, ((CraftWorld)event.getTo().getWorld()).getHandle(), event); } protected Vec3D a(EnumDirection.EnumAxis enumdirection_enumaxis, BlockUtil.Rectangle blockutil_rectangle) { return BlockPortalShape.a(blockutil_rectangle, enumdirection_enumaxis, getPositionVector(), a(getPose())); } protected CraftPortalEvent callPortalEvent(Entity entity, WorldServer exitWorldServer, BlockPosition exitPosition, PlayerTeleportEvent.TeleportCause cause, int searchRadius, int creationRadius) { CraftEntity craftEntity = entity.getBukkitEntity(); Location enter = craftEntity.getLocation(); Location exit = new Location((World)exitWorldServer.getWorld(), exitPosition.getX(), exitPosition.getY(), exitPosition.getZ()); EntityPortalEvent event = new EntityPortalEvent((org.bukkit.entity.Entity)craftEntity, enter, exit, searchRadius); event.getEntity().getServer().getPluginManager().callEvent((Event)event); if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !entity.isAlive()) return null;  return new CraftPortalEvent(event); } protected Optional<BlockUtil.Rectangle> a(WorldServer worldserver, BlockPosition blockposition, boolean flag, int searchRadius, boolean canCreatePortal, int createRadius) { return worldserver.getTravelAgent().findPortal(blockposition, searchRadius); } public boolean canPortal() { return (isAlive() && this.valid); } public float a(Explosion explosion, IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata, Fluid fluid, float f) { return f; } public boolean a(Explosion explosion, IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata, float f) { return true; } public int bO() { return 3; } public boolean isIgnoreBlockTrigger() { return false; } public void appendEntityCrashDetails(CrashReportSystemDetails crashreportsystemdetails) { crashreportsystemdetails.a("Entity Type", () -> EntityTypes.getName(getEntityType()) + " (" + getClass().getCanonicalName() + ")"); crashreportsystemdetails.a("Entity ID", Integer.valueOf(this.id)); crashreportsystemdetails.a("Entity Name", () -> getDisplayName().getString()); crashreportsystemdetails.a("Entity's Exact location", String.format(Locale.ROOT, "%.2f, %.2f, %.2f", new Object[] { Double.valueOf(locX()), Double.valueOf(locY()), Double.valueOf(locZ()) })); crashreportsystemdetails.a("Entity's Block location", CrashReportSystemDetails.a(MathHelper.floor(locX()), MathHelper.floor(locY()), MathHelper.floor(locZ()))); Vec3D vec3d = getMot(); crashreportsystemdetails.a("Entity's Momentum", String.format(Locale.ROOT, "%.2f, %.2f, %.2f", new Object[] { Double.valueOf(vec3d.x), Double.valueOf(vec3d.y), Double.valueOf(vec3d.z) })); crashreportsystemdetails.a("Entity's Passengers", () -> getPassengers().toString()); crashreportsystemdetails.a("Entity's Vehicle", () -> getVehicle().toString()); } public final void setUUID(UUID uuid) { a_(uuid); } public void a_(UUID uuid) { this.uniqueID = uuid; this.ae = this.uniqueID.toString(); } public UUID getUniqueID() { return this.uniqueID; } public String getUniqueIDString() { return this.ae; } public String getName() { return this.ae; } public final boolean isPushedByWater() { return bU(); } public boolean bU() { return pushedByWater(); } public boolean pushedByWater() { return true; } public IChatBaseComponent getScoreboardDisplayName() { return ScoreboardTeam.a(getScoreboardTeam(), getDisplayName()).format(chatmodifier -> chatmodifier.setChatHoverable(ca()).setInsertion(getUniqueIDString())); } public void setCustomName(@Nullable IChatBaseComponent ichatbasecomponent) { this.datawatcher.set(aq, Optional.ofNullable(ichatbasecomponent)); } @Nullable public IChatBaseComponent getCustomName() { return ((Optional<IChatBaseComponent>)this.datawatcher.<Optional<IChatBaseComponent>>get(aq)).orElse(null); } public boolean hasCustomName() { return ((Optional)this.datawatcher.<Optional>get((DataWatcherObject)aq)).isPresent(); } public void setCustomNameVisible(boolean flag) { this.datawatcher.set(ar, Boolean.valueOf(flag)); } public boolean getCustomNameVisible() { return ((Boolean)this.datawatcher.<Boolean>get(ar)).booleanValue(); } public final void enderTeleportAndLoad(double d0, double d1, double d2) { if (this.world instanceof WorldServer) { ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(new BlockPosition(d0, d1, d2)); ((WorldServer)this.world).getChunkProvider().addTicket(TicketType.POST_TELEPORT, chunkcoordintpair, 0, Integer.valueOf(getId())); this.world.getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z); enderTeleportTo(d0, d1, d2); }  } public void enderTeleportTo(double d0, double d1, double d2) { if (this.world instanceof WorldServer) { WorldServer worldserver = (WorldServer)this.world; setPositionRotation(d0, d1, d2, this.yaw, this.pitch); co().forEach(entity -> { worldserver.chunkCheck(entity); entity.az = true; Iterator<Entity> iterator = entity.passengers.iterator(); while (iterator.hasNext()) { Entity entity1 = iterator.next(); entity.a(entity1, Entity::teleportAndSync); }  }); }  } public void a(DataWatcherObject<?> datawatcherobject) { if (POSE.equals(datawatcherobject)) updateSize();  } public void updateSize() { EntitySize entitysize = this.size; EntityPose entitypose = getPose(); EntitySize entitysize1 = a(entitypose); this.size = entitysize1; this.headHeight = getHeadHeight(entitypose, entitysize1); if (entitysize1.width < entitysize.width) { double d0 = entitysize1.width / 2.0D; a(new AxisAlignedBB(locX() - d0, locY(), locZ() - d0, locX() + d0, locY() + entitysize1.height, locZ() + d0)); } else { AxisAlignedBB axisalignedbb = getBoundingBox(); a(new AxisAlignedBB(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.minX + entitysize1.width, axisalignedbb.minY + entitysize1.height, axisalignedbb.minZ + entitysize1.width)); if (entitysize1.width > entitysize.width && !this.justCreated && !this.world.isClientSide) { float f = entitysize.width - entitysize1.width; move(EnumMoveType.SELF, new Vec3D(f, 0.0D, f)); }  }  } public EnumDirection getDirection() { return EnumDirection.fromAngle(this.yaw); } public EnumDirection getAdjustedDirection() { return getDirection(); } protected ChatHoverable ca() { return new ChatHoverable((ChatHoverable.EnumHoverAction)ChatHoverable.EnumHoverAction.SHOW_ENTITY, (T)new ChatHoverable.b(getEntityType(), getUniqueID(), getDisplayName())); } public boolean a(EntityPlayer entityplayer) { return true; } public AxisAlignedBB getBoundingBox() { return this.boundingBox; } protected AxisAlignedBB d(EntityPose entitypose) { EntitySize entitysize = a(entitypose); float f = entitysize.width / 2.0F; Vec3D vec3d = new Vec3D(locX() - f, locY(), locZ() - f); Vec3D vec3d1 = new Vec3D(locX() + f, locY() + entitysize.height, locZ() + f); return new AxisAlignedBB(vec3d, vec3d1); } public final void setBoundingBox(AxisAlignedBB axisalignedbb) { a(axisalignedbb); } public void a(AxisAlignedBB axisalignedbb) { double minX = axisalignedbb.minX; double minY = axisalignedbb.minY; double minZ = axisalignedbb.minZ; double maxX = axisalignedbb.maxX; double maxY = axisalignedbb.maxY; double maxZ = axisalignedbb.maxZ; double len = axisalignedbb.maxX - axisalignedbb.minX; if (len < 0.0D) maxX = minX;  if (len > 64.0D) maxX = minX + 64.0D;  len = axisalignedbb.maxY - axisalignedbb.minY; if (len < 0.0D) maxY = minY;  if (len > 64.0D) maxY = minY + 64.0D;  len = axisalignedbb.maxZ - axisalignedbb.minZ; if (len < 0.0D) maxZ = minZ;  if (len > 64.0D) maxZ = minZ + 64.0D;  this.boundingBox = new AxisAlignedBB(minX, minY, minZ, maxX, maxY, maxZ); } protected float getHeadHeight(EntityPose entitypose, EntitySize entitysize) { return entitysize.height * 0.85F; } public final float getHeadHeight() { return this.headHeight; } public boolean a_(int i, ItemStack itemstack) { return false; } public void sendMessage(IChatBaseComponent ichatbasecomponent, UUID uuid) {} public World getWorld() { return this.world; } @Nullable public MinecraftServer getMinecraftServer() { return this.world.getMinecraftServer(); } public EnumInteractionResult a(EntityHuman entityhuman, Vec3D vec3d, EnumHand enumhand) { return EnumInteractionResult.PASS; } public boolean ch() { return false; } public void a(EntityLiving entityliving, Entity entity) { if (entity instanceof EntityLiving) EnchantmentManager.a((EntityLiving)entity, entityliving);  EnchantmentManager.b(entityliving, entity); } public void b(EntityPlayer entityplayer) {} public void c(EntityPlayer entityplayer) {} public float a(EnumBlockRotation enumblockrotation) { float f = MathHelper.g(this.yaw); switch (enumblockrotation) { case LEFT_RIGHT: return f + 180.0F;case FRONT_BACK: return f + 270.0F;case null: return f + 90.0F; }  return f; } public float a(EnumBlockMirror enumblockmirror) { float f = MathHelper.g(this.yaw); switch (enumblockmirror) { case LEFT_RIGHT: return -f;case FRONT_BACK: return 180.0F - f; }  return f; } public boolean ci() { return false; } public boolean cj() { boolean flag = this.az; this.az = false; return flag; } public boolean ck() { boolean flag = this.au; this.au = false; return flag; } @Nullable public Entity getRidingPassenger() { return null; } public List<Entity> getPassengers() { return this.passengers.isEmpty() ? Collections.<Entity>emptyList() : Lists.newArrayList(this.passengers); } public boolean w(Entity entity) { Entity entity1; Iterator<Entity> iterator = getPassengers().iterator(); do { if (!iterator.hasNext()) return false;  entity1 = iterator.next(); } while (!entity1.equals(entity)); return true; } public boolean a(Class<? extends Entity> oclass) { Entity entity; Iterator<Entity> iterator = getPassengers().iterator(); do { if (!iterator.hasNext()) return false;  entity = iterator.next(); } while (!oclass.isAssignableFrom(entity.getClass())); return true; } public Collection<Entity> getAllPassengers() { Set<Entity> set = Sets.newHashSet(); Iterator<Entity> iterator = getPassengers().iterator(); while (iterator.hasNext()) { Entity entity = iterator.next(); set.add(entity); entity.a(false, set); }  return set; } public Stream<Entity> co() { return Stream.concat(Stream.of(this), this.passengers.stream().flatMap(Entity::co)); } public boolean hasSinglePlayerPassenger() { Set<Entity> set = Sets.newHashSet(); a(true, set); return (set.size() == 1); } private void a(boolean flag, Set<Entity> set) { for (Iterator<Entity> iterator = getPassengers().iterator(); iterator.hasNext(); entity.a(flag, set)) { Entity entity = iterator.next(); if (!flag || EntityPlayer.class.isAssignableFrom(entity.getClass())) set.add(entity);  }  } public Entity getRootVehicle() { Entity entity; for (entity = this; entity.isPassenger(); entity = entity.getVehicle()); return entity; } public boolean isSameVehicle(Entity entity) { return (getRootVehicle() == entity.getRootVehicle()); } public boolean cr() { Entity entity = getRidingPassenger(); return (entity instanceof EntityHuman) ? ((EntityHuman)entity).ey() : (!this.world.isClientSide); } protected static Vec3D a(double d0, double d1, float f) { double d2 = (d0 + d1 + 9.999999747378752E-6D) / 2.0D; float f1 = -MathHelper.sin(f * 0.017453292F); float f2 = MathHelper.cos(f * 0.017453292F); float f3 = Math.max(Math.abs(f1), Math.abs(f2)); return new Vec3D(f1 * d2 / f3, 0.0D, f2 * d2 / f3); } public Vec3D b(EntityLiving entityliving) { return new Vec3D(locX(), (getBoundingBox()).maxY, locZ()); } @Nullable public Entity getVehicle() { return this.vehicle; } public EnumPistonReaction getPushReaction() { return EnumPistonReaction.NORMAL; } public SoundCategory getSoundCategory() { return SoundCategory.NEUTRAL; } public int getMaxFireTicks() { return 1; } public CommandListenerWrapper getCommandListener() { return new CommandListenerWrapper(this, getPositionVector(), bh(), (this.world instanceof WorldServer) ? (WorldServer)this.world : null, y(), getDisplayName().getString(), getScoreboardDisplayName(), this.world.getMinecraftServer(), this); } protected int y() { return 0; } public boolean k(int i) { return (y() >= i); } public boolean shouldSendSuccess() { return this.world.getGameRules().getBoolean(GameRules.SEND_COMMAND_FEEDBACK); } public boolean shouldSendFailure() { return true; } public boolean shouldBroadcastCommands() { return true; } public void a(ArgumentAnchor.Anchor argumentanchor_anchor, Vec3D vec3d) { Vec3D vec3d1 = argumentanchor_anchor.a(this); double d0 = vec3d.x - vec3d1.x; double d1 = vec3d.y - vec3d1.y; double d2 = vec3d.z - vec3d1.z; double d3 = MathHelper.sqrt(d0 * d0 + d2 * d2); this.pitch = MathHelper.g((float)-(MathHelper.d(d1, d3) * 57.2957763671875D)); this.yaw = MathHelper.g((float)(MathHelper.d(d2, d0) * 57.2957763671875D) - 90.0F); setHeadRotation(this.yaw); this.lastPitch = this.pitch; this.lastYaw = this.yaw; } public boolean a(Tag<FluidType> tag, double d0) { AxisAlignedBB axisalignedbb = getBoundingBox().shrink(0.001D); int i = MathHelper.floor(axisalignedbb.minX); int j = MathHelper.f(axisalignedbb.maxX); int k = MathHelper.floor(axisalignedbb.minY); int l = MathHelper.f(axisalignedbb.maxY); int i1 = MathHelper.floor(axisalignedbb.minZ); int j1 = MathHelper.f(axisalignedbb.maxZ); if (!this.world.isAreaLoaded(i, k, i1, j, l, j1)) return false;  double d1 = 0.0D; boolean flag = bU(); boolean flag1 = false; Vec3D vec3d = Vec3D.ORIGIN; int k1 = 0; BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(); for (int l1 = i; l1 < j; l1++) { for (int i2 = k; i2 < l; i2++) { for (int j2 = i1; j2 < j1; j2++) { blockposition_mutableblockposition.d(l1, i2, j2); Fluid fluid = this.world.getFluid(blockposition_mutableblockposition); if (fluid.a(tag)) { double d2 = (i2 + fluid.getHeight(this.world, blockposition_mutableblockposition)); if (d2 >= axisalignedbb.minY) { flag1 = true; d1 = Math.max(d2 - axisalignedbb.minY, d1); if (flag) { Vec3D vec3d1 = fluid.c(this.world, blockposition_mutableblockposition); if (d1 < 0.4D) vec3d1 = vec3d1.a(d1);  vec3d = vec3d.e(vec3d1); k1++; }  }  }  }  }  }  if (vec3d.f() > 0.0D) { if (k1 > 0) vec3d = vec3d.a(1.0D / k1);  if (!(this instanceof EntityHuman)) vec3d = vec3d.d();  Vec3D vec3d2 = getMot(); vec3d = vec3d.a(d0 * 1.0D); double d3 = 0.003D; if (Math.abs(vec3d2.x) < 0.003D && Math.abs(vec3d2.z) < 0.003D && vec3d.f() < 0.0045000000000000005D) vec3d = vec3d.d().a(0.0045000000000000005D);  setMot(getMot().e(vec3d)); }  this.M.put(tag, d1); return flag1; } public double b(Tag<FluidType> tag) { return this.M.getDouble(tag); } public double cw() { return (getHeadHeight() < 0.4D) ? 0.0D : 0.4D; } public final float getWidth() { return this.size.width; } public final float getHeight() { return this.size.height; } public EntitySize a(EntityPose entitypose) { return this.f.l(); } public Vec3D getPositionVector() { return this.loc; } public BlockPosition getChunkCoordinates() { return this.locBlock; } public void setMot(Vec3D vec3d) { synchronized (this.posLock) {
/* 3515 */       this.mot = vec3d;
/*      */     }  }
/*      */ 
/*      */   
/*      */   public void setMot(double d0, double d1, double d2) {
/* 3520 */     setMot(new Vec3D(d0, d1, d2));
/*      */   }
/*      */   
/*      */   public final double locX() {
/* 3524 */     return this.loc.x;
/*      */   }
/*      */   
/*      */   public double c(double d0) {
/* 3528 */     return this.loc.x + getWidth() * d0;
/*      */   }
/*      */   
/*      */   public double d(double d0) {
/* 3532 */     return c((2.0D * this.random.nextDouble() - 1.0D) * d0);
/*      */   }
/*      */   
/*      */   public final double locY() {
/* 3536 */     return this.loc.y;
/*      */   }
/*      */   
/*      */   public double e(double d0) {
/* 3540 */     return this.loc.y + getHeight() * d0;
/*      */   }
/*      */   
/*      */   public double cE() {
/* 3544 */     return e(this.random.nextDouble());
/*      */   }
/*      */   
/*      */   public double getHeadY() {
/* 3548 */     return this.loc.y + this.headHeight;
/*      */   }
/*      */   
/*      */   public final double locZ() {
/* 3552 */     return this.loc.z;
/*      */   }
/*      */   
/*      */   public double f(double d0) {
/* 3556 */     return this.loc.z + getWidth() * d0;
/*      */   }
/*      */   
/*      */   public double g(double d0) {
/* 3560 */     return f((2.0D * this.random.nextDouble() - 1.0D) * d0);
/*      */   }
/*      */ 
/*      */ 
/*      */   
/*      */   public void setPositionRaw(double d0, double d1, double d2) {
/* 3566 */     if (!(this instanceof EntityHanging) && (this.loc.x != d0 || this.loc.y != d1 || this.loc.z != d2)) {
/* 3567 */       setBoundingBox(this.size.a(d0, d1, d2));
/*      */     }
/*      */     
/* 3570 */     if (this.loc.x != d0 || this.loc.y != d1 || this.loc.z != d2) {
/* 3571 */       synchronized (this.posLock) {
/* 3572 */         this.loc = new Vec3D(d0, d1, d2);
/*      */       } 
/* 3574 */       int i = MathHelper.floor(d0);
/* 3575 */       int j = MathHelper.floor(d1);
/* 3576 */       int k = MathHelper.floor(d2);
/*      */       
/* 3578 */       if (i != this.locBlock.getX() || j != this.locBlock.getY() || k != this.locBlock.getZ()) {
/* 3579 */         this.locBlock = new BlockPosition(i, j, k);
/*      */       }
/*      */       
/* 3582 */       this.au = true;
/*      */     } 
/*      */   }
/*      */   
/*      */   public void checkDespawn() {}
/*      */   
/*      */   protected abstract void initDatawatcher();
/*      */   
/*      */   protected abstract void loadData(NBTTagCompound paramNBTTagCompound);
/*      */   
/*      */   protected abstract void saveData(NBTTagCompound paramNBTTagCompound);
/*      */   
/*      */   public abstract Packet<?> P();
/*      */   
/*      */   @FunctionalInterface
/*      */   public static interface a {
/*      */     void accept(Entity param1Entity, double param1Double1, double param1Double2, double param1Double3);
/*      */   }
/*      */ }


/* Location:              C:\Users\Josep\Downloads\Decompile Minecraft\tuinity-1.16.3.jar!\net\minecraft\server\v1_16_R2\Entity.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */